<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Pixel Animator</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<style>:root{--bg-primary:#0a0a0a;--bg-secondary:#1a1a1a;--bg-tertiary:#222222;--accent-primary:#10b981;--accent-secondary:#ef4444;--text-primary:#ffffff;--text-secondary:#b0b0b0;--text-muted:#666666;--border-color:#333333;--shadow:0 4px 20px rgba(0,0,0,0.5);--shadow-light:0 2px 10px rgba(0,0,0,0.3);--radius:8px;--transition:all 0.2s cubic-bezier(0.4,0,0.2,1)}*{box-sizing:border-box}body{margin:0;font-family:'Inter',sans-serif;background:linear-gradient(135deg,var(--bg-primary) 0%,var(--bg-secondary) 100%);color:var(--text-primary);display:flex;flex-direction:column;align-items:center;min-height:100vh;overflow:hidden}.header{width:100%;padding:20px;background:rgba(10,10,10,0.8);backdrop-filter:blur(10px);border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center}h1{margin:0;font-size:24px;font-weight:700;background:linear-gradient(135deg,var(--accent-primary),#059669);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;background-size:400% 400%;animation:gradientShift 4s ease infinite}@keyframes gradientShift{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}.header-info{display:flex;gap:20px;align-items:center;font-size:14px;color:var(--text-secondary)}#toolbar{display:flex;flex-wrap:wrap;gap:8px;padding:20px;background:var(--bg-secondary);border-bottom:1px solid var(--border-color);width:100%;justify-content:center;align-items:center}.tool-group{display:flex;gap:8px;align-items:center;background:var(--bg-tertiary);padding:8px 12px;border-radius:var(--radius);border:1px solid var(--border-color)}button{padding:8px 12px;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500;background:transparent;color:var(--text-secondary);transition:var(--transition);position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center}button i{font-size:14px}button::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.1),transparent);transition:left 0.5s}button:hover::before{left:100%}button:hover{color:var(--text-primary);background:rgba(255,255,255,0.05);transform:translateY(-1px)}button.active{background:var(--accent-primary);color:#000;box-shadow:var(--shadow-light)}input[type="color"]{width:32px;height:32px;border:none;border-radius:4px;cursor:pointer;padding:0;background:transparent}input[type="number"],input[type="range"]{padding:6px 8px;border:1px solid var(--border-color);border-radius:4px;background:var(--bg-tertiary);color:var(--text-primary);font-size:14px}input[type="range"]{width:120px;accent-color:var(--accent-primary)}#canvasContainer{display:flex;justify-content:center;align-items:center;flex:1;width:100%;overflow:hidden;position:relative;background:var(--bg-primary)}canvas{border:2px solid var(--border-color);border-radius:var(--radius);image-rendering:pixelated;cursor:crosshair;box-shadow:var(--shadow);background:var(--bg-primary)}#frames{display:flex;gap:8px;padding:20px;background:var(--bg-secondary);width:100%;overflow-x:auto;border-top:1px solid var(--border-color);align-items:center;justify-content:center}.frame-container{position:relative;display:inline-flex;flex-direction:column;align-items:center;gap:4px}canvas.frame{width:40px;height:40px;border:2px solid var(--border-color);border-radius:4px;cursor:pointer;transition:var(--transition);box-shadow:var(--shadow-light)}canvas.frame:hover{transform:scale(1.05);box-shadow:var(--shadow)}canvas.frame.active{border-color:var(--accent-primary);box-shadow:0 0 0 2px var(--accent-primary)}.frame-label{font-size:12px;color:var(--text-secondary);font-weight:500}.status-bar{width:100%;padding:10px 20px;background:var(--bg-tertiary);border-top:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;font-size:14px;color:var(--text-secondary)}#progressContainer{display:flex;align-items:center;gap:8px;flex:1;justify-content:center}progress{width:150px;height:8px;border-radius:4px;background:var(--bg-secondary)}.playing{color:var(--accent-primary);animation:pulse 1s infinite}@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}#projectModal,#guideModal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:1000;justify-content:center;align-items:center}.modal-content{background:var(--bg-secondary);padding:20px;border-radius:var(--radius);width:90%;max-width:500px;max-height:80%;overflow-y:auto}#projectList div{display:flex;justify-content:space-between;align-items:center;padding:10px;background:var(--bg-tertiary);border-radius:4px;margin-bottom:5px}#projectList button{padding:4px 8px;font-size:12px;margin-left:5px}.modal-buttons{display:flex;gap:10px;margin-top:20px}.modal-buttons button{flex:1}#guideContent h3{margin-top:0;font-size:18px;color:var(--accent-primary)}#guideContent ul{list-style-type:none;padding:0}#guideContent li{margin-bottom:10px;padding:10px;background:var(--bg-tertiary);border-radius:4px}#mobileWarning{display:none;position:fixed;top:20px;right:20px;background:var(--accent-secondary);color:white;padding:10px;border-radius:var(--radius);z-index:1001;box-shadow:var(--shadow);font-size:12px;max-width:200px}@media (max-width:768px){#toolbar{flex-direction:column;gap:12px}.tool-group{width:100%;justify-content:center}#frames{gap:4px;padding:10px}canvas.frame{width:30px;height:30px}.header{flex-direction:column;gap:10px;text-align:center}#mobileWarning{top:10px;right:10px;max-width:150px;font-size:10px}}</style>
</head>
<body>
<div id="mobileWarning">
  <i class="fas fa-mobile-alt"></i> Optimized for desktop. Touch controls may vary.
</div>

<div class="header">
  <h1>Pixel Animator</h1>
  <div class="header-info">
    <span id="frameCount">Frame: 1/1</span>
    <span id="fpsDisplay">5 FPS</span>
    <span id="zoomDisplay">100%</span>
  </div>
</div>

<div id="toolbar">
  <div class="tool-group">
    <button id="b" title="Brush"><i class="fas fa-paint-brush"></i></button>
    <button id="e" title="Eraser"><i class="fas fa-eraser"></i></button>
    <button id="panBtn" title="Pan"><i class="fas fa-hand-paper"></i></button>
    <input type="color" id="c" value="#ff0000" title="Color">
    <button id="pickBtn" title="Color Picker"><i class="fas fa-eye-dropper"></i></button>
    <input type="number" id="s" value="1" min="1" max="10" style="width:50px" title="Size">
    <span>|</span>
    <input type="color" id="bg" value="#222222" title="Background Color">
  </div>
  
  <div class="tool-group">
    <button id="p" title="Play/Pause"><i class="fas fa-play"></i></button>
    <button id="d" title="Clear Frame"><i class="fas fa-trash-alt"></i></button>
    <button id="a" title="New Frame"><i class="fas fa-plus"></i></button>
    <button id="r" title="Delete Frame"><i class="fas fa-minus"></i></button>
  </div>
  
  <div class="tool-group">
    <span>FPS</span>
    <input type="number" id="fpsInput" value="5" min="1" max="60" style="width:50px;" title="FPS">
  </div>
  
  <div class="tool-group">
    <button id="u" title="Undo"><i class="fas fa-undo"></i></button>
    <button id="redo" title="Redo"><i class="fas fa-redo"></i></button>
    <button id="saveBtn" title="Save Project"><i class="fas fa-save"></i></button>
    <button id="exp" title="Export"><i class="fas fa-download"></i></button>
    <button id="impBtn" title="Import"><i class="fas fa-upload"></i></button>
    <button id="projectsBtn" title="Projects"><i class="fas fa-folder-open"></i></button>
    <button id="guideBtn" title="Beginner Guide"><i class="fas fa-question-circle"></i></button>
  </div>
</div>

<div id="canvasContainer">
  <canvas id="can"></canvas>
</div>

<div id="frames"></div>

<div class="status-bar">
  <span id="statusText">No project selected. Select a project to draw.</span>
  <div id="progressContainer" style="display:none;">
    <progress id="progressBar" value="0" max="100"></progress>
    <span id="progressText">0 frames</span>
  </div>
  <span id="playingIndicator" class="playing" style="display:none;">⏸️ Playing</span>
</div>

<input type="file" id="impFile" style="display:none" accept=".pxanim">

<div id="projectModal">
  <div class="modal-content">
    <h2>Projects</h2>
    <div id="projectList"></div>
    <div class="modal-buttons">
      <button id="newProjBtn">New Project</button>
      <button id="closeModal">Close</button>
    </div>
  </div>
</div>

<div id="guideModal">
  <div class="modal-content">
    <h2>Beginner Guide</h2>
    <div id="guideContent">
      <h3>Welcome to Pixel Animator!</h3>
      <ul>
        <li><strong>Getting Started:</strong> Click "Projects" to create or load a project. Set dimensions when creating new.</li>
        <li><strong>Drawing:</strong> Use Brush/Eraser tools. Select color and size. Click and drag on canvas to draw.</li>
        <li><strong>Frames:</strong> Add new frames with +, switch by clicking thumbnails. Copy current when adding.</li>
        <li><strong>Playback:</strong> Set FPS and click Play to animate. Use Pan/Zoom with mouse wheel.</li>
        <li><strong>Save/Export:</strong> Auto-saves to browser storage. Export as .pxanim file.</li>
        <li><strong>Tips:</strong> Undo/Redo for changes. Color Picker to sample colors. Optimized for desktop.</li>
      </ul>
    </div>
    <div class="modal-buttons">
      <button id="closeGuide">Got it!</button>
    </div>
  </div>
</div>

<script>
const container = document.getElementById('canvasContainer');
const can = document.getElementById('can');
const ctx = can.getContext('2d', { alpha: false });
let brush = true, color = "#ff0000", bgColor = "#222222", size = 1, gridW = 320, gridH = 320, logicalWidth = 320, logicalHeight = 320, drawing = false, zoom = 1, panX, panY, mode = 'draw', isPanning = false, startX = 0, startY = 0, startPanX = 0, startPanY = 0, frameInterval = 200, rafId = 0;
let frames = [new Array(gridW * gridH).fill(0)], cur = 0, history = [], future = [], playI = null, atlas = ["t"], ci = {"transparent": 0};
let cssWidth, cssHeight;
let worker;
let offscreenCanvas, offscreenCtx;
let dirtyFrame = true;
let paletteRGBA = []; // Precomputed RGBA for each color index
let fps = 5;
let currentProjectId = null;
let autoSaveInterval = null;

panX = logicalWidth / 2;
panY = logicalHeight / 2;

const modal = document.getElementById('projectModal');
const guideModal = document.getElementById('guideModal');
const projectList = document.getElementById('projectList');
const mobileWarning = document.getElementById('mobileWarning');

// Detect mobile
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
}

if (isMobile()) {
  mobileWarning.style.display = 'block';
}

// Show guide on first load
if (!localStorage.getItem('guideSeen')) {
  guideModal.style.display = 'flex';
  localStorage.setItem('guideSeen', 'true');
}

function hexToRGBA(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return new Uint8ClampedArray([r, g, b, 255]);
}

function updatePalette() {
  paletteRGBA = atlas.map(col => col === 't' ? new Uint8ClampedArray([0, 0, 0, 0]) : hexToRGBA(col));
}

function invertColor(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return '#' + ((255 - r).toString(16).padStart(2, '0')) + ((255 - g).toString(16).padStart(2, '0')) + ((255 - b).toString(16).padStart(2, '0'));
}

// Create offscreen canvas
function initOffscreen() {
  offscreenCanvas = document.createElement('canvas');
  offscreenCanvas.width = logicalWidth;
  offscreenCanvas.height = logicalHeight;
  offscreenCtx = offscreenCanvas.getContext('2d', { alpha: true });
}

function getProjectData() {
  return {
    logicalWidth,
    logicalHeight,
    gridW,
    gridH,
    frames: frames.map(f => [...f]),
    atlas: [...atlas],
    ci: { ...ci }
  };
}

let dbPromise = null;
async function initDB() {
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open('PixelAnimatorDB', 2);
    request.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('projects')) {
        db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
      }
    };
    request.onsuccess = (e) => resolve(e.target.result);
    request.onerror = () => reject(request.error);
  });
  return dbPromise;
}

async function saveProject(name, projectData) {
  const db = await initDB();
  const tx = db.transaction('projects', 'readwrite');
  const store = tx.objectStore('projects');
  const project = { name, data: JSON.stringify(projectData), timestamp: Date.now() };
  const req = store.add(project);
  return new Promise((res, rej) => {
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}

async function updateProject(id, projectData) {
  if (!id) {
    console.warn('No project ID provided for update');
    return false;
  }
  try {
    const db = await initDB();
    const tx = db.transaction('projects', 'readwrite');
    const store = tx.objectStore('projects');
    const getReq = store.get(id);
    return new Promise((res, rej) => {
      getReq.onsuccess = () => {
        const old = getReq.result;
        if (old) {
          const updateReq = store.put({ ...old, data: JSON.stringify(projectData), timestamp: Date.now() });
          updateReq.onsuccess = () => res(true);
          updateReq.onerror = () => rej(updateReq.error);
        } else {
          rej('Project not found');
        }
      };
      getReq.onerror = () => rej(getReq.error);
    });
  } catch (e) {
    console.error('Update project error:', e);
    return false;
  }
}

async function loadProjects() {
  const db = await initDB();
  const tx = db.transaction('projects', 'readonly');
  const store = tx.objectStore('projects');
  const req = store.getAll();
  return new Promise((res, rej) => {
    req.onsuccess = () => res(req.result);
    req.onerror = () => rej(req.error);
  });
}

async function loadProject(id) {
  if (!id) {
    alert('Invalid project ID');
    return;
  }
  try {
    document.getElementById('statusText').textContent = 'Loading project...';
    const db = await initDB();
    const tx = db.transaction('projects', 'readonly');
    const store = tx.objectStore('projects');
    const req = store.get(id);
    return new Promise((res, rej) => {
      req.onsuccess = () => {
        const p = req.result;
        if (!p) return rej('Project not found');
        const data = JSON.parse(p.data);
        logicalWidth = data.logicalWidth;
        logicalHeight = data.logicalHeight;
        gridW = data.gridW;
        gridH = data.gridH;
        frames = data.frames.map(f => [...f]);
        atlas = [...data.atlas];
        ci = { ...data.ci };
        panX = logicalWidth / 2;
        panY = logicalHeight / 2;
        zoom = 1;
        document.getElementById('zoomDisplay').textContent = '100%';
        updatePalette();
        initOffscreen();
        updateCanvasSize();
        cur = 0;
        updateFrames();
        dirtyFrame = true;
        requestRender();
        history = [];
        future = [];
        currentProjectId = id;
        if (autoSaveInterval) clearInterval(autoSaveInterval);
        autoSaveInterval = setInterval(async () => {
          if (!currentProjectId) return;
          try {
            await updateProject(currentProjectId, getProjectData());
            document.getElementById('statusText').textContent = 'Auto-saved';
            setTimeout(() => { document.getElementById('statusText').textContent = 'Ready to draw'; }, 1000);
          } catch (e) {
            console.error('Auto-save failed:', e);
          }
        }, 5000);
        updateStatus();
        modal.style.display = 'none';
        res();
      };
      req.onerror = () => rej(req.error);
    });
  } catch (e) {
    alert('Error loading project: ' + e.message);
    document.getElementById('statusText').textContent = 'Error loading project';
  }
}

async function deleteProject(id) {
  if (!id) {
    alert('Invalid project ID');
    return;
  }
  if (!confirm('Are you sure you want to delete this project?')) return;
  try {
    const db = await initDB();
    const tx = db.transaction('projects', 'readwrite');
    const store = tx.objectStore('projects');
    await new Promise((res, rej) => {
      const req = store.delete(id);
      req.onsuccess = () => res();
      req.onerror = () => rej(req.error);
    });
    await populateProjects();
    if (currentProjectId === id) {
      currentProjectId = null;
      clearInterval(autoSaveInterval);
      autoSaveInterval = null;
      logicalWidth = 320;
      logicalHeight = 320;
      gridW = 320;
      gridH = 320;
      frames = [new Array(gridW * gridH).fill(0)];
      atlas = ["t"];
      ci = {"transparent": 0};
      cur = 0;
      history = [];
      future = [];
      panX = logicalWidth / 2;
      panY = logicalHeight / 2;
      zoom = 1;
      document.getElementById('zoomDisplay').textContent = '100%';
      updatePalette();
      initOffscreen();
      updateCanvasSize();
      updateFrames();
      dirtyFrame = true;
      requestRender();
      updateStatus();
      document.getElementById('statusText').textContent = 'Project deleted. Select another or create new.';
    }
  } catch (e) {
    alert('Error deleting project: ' + e.message);
  }
}

async function populateProjects() {
  try {
    const db = await initDB();
    const tx = db.transaction('projects', 'readonly');
    const store = tx.objectStore('projects');
    const keyReq = store.getAllKeys();
    const keys = await new Promise((res, rej) => {
      keyReq.onsuccess = () => res(keyReq.result);
      keyReq.onerror = () => rej(keyReq.error);
    });
    const projects = await Promise.all(keys.map(key =>
      new Promise((res, rej) => {
        const req = store.get(key);
        req.onsuccess = () => {
          const p = req.result;
          if (p) {
            p.id = key;
          }
          res(p);
        };
        req.onerror = () => rej(req.error);
      })
    ));
    projectList.innerHTML = '';
    if (projects.length === 0) {
      const div = document.createElement('div');
      div.textContent = 'No projects yet. Click "New Project" to create one!';
      div.style.color = 'var(--text-secondary)';
      div.style.textAlign = 'center';
      div.style.padding = '20px';
      projectList.appendChild(div);
    } else {
      projects.forEach(p => {
        if (!p) return;
        const div = document.createElement('div');
        div.style = 'display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--bg-tertiary); border-radius: 4px; margin-bottom: 5px;';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = `${p.name} (${new Date(p.timestamp).toLocaleString()})`;
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load';
        loadBtn.onclick = () => loadProject(p.id);
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.style.background = 'var(--accent-secondary)';
        delBtn.onclick = () => deleteProject(p.id);
        const btnDiv = document.createElement('div');
        btnDiv.append(loadBtn, delBtn);
        div.append(nameSpan, btnDiv);
        projectList.appendChild(div);
      });
    }
  } catch (e) {
    console.error('Error populating projects:', e);
    projectList.innerHTML = '<div style="color: var(--accent-secondary);">Error loading projects</div>';
  }
}

// Create Web Worker from Blob
const workerScript = `
function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

self.onmessage = function(e) {
  const { type, data } = e.data;
  if (type === 'encode') {
    const { atlas, frames, logicalWidth, logicalHeight, gridW, gridH } = data;
    let palette = atlas.map(c => c === 't' ? 't' : c.slice(1)).join('');
    let frameData = frames.map(frame => {
      let run = [], count = 1;
      for (let i = 1; i <= frame.length; i++) {
        if (i < frame.length && frame[i] === frame[i - 1]) {
          count++;
        } else {
          run.push(\`\${frame[i - 1]}:\${count}\`);
          count = 1;
        }
      }
      return run.join(',');
    }).join(';');
    const encoded = \`\${palette}|\${logicalWidth}|\${logicalHeight}|\${gridW}|\${gridH}|\${frameData}\`;
    self.postMessage({ type: 'encoded', data: encoded });
  } else if (type === 'decode') {
    const { encoded } = data;
    try {
      const parts = encoded.split('|');
      const paletteStr = parts[0];
      let atlas = [];
      let ci = { transparent: 0 };
      let idx = 0;
      while (idx < paletteStr.length) {
        if (paletteStr[idx] === 't') {
          atlas.push('t');
          idx++;
        } else {
          const hex = '#' + paletteStr.substr(idx, 6);
          atlas.push(hex);
          ci[hex] = atlas.length - 1;
          idx += 6;
        }
      }
      let frameStr = parts[5] || '';
      let logicalWidth = parseInt(parts[1]);
      let logicalHeight = parseInt(parts[2]);
      let gridW = parseInt(parts[3]);
      let gridH = parseInt(parts[4]);
      if (parts.length === 4) { // Legacy
        const pixPerGrid = parseInt(parts[1]);
        const grids = parseInt(parts[2]);
        logicalWidth = pixPerGrid * grids;
        logicalHeight = logicalWidth;
        gridW = grids;
        gridH = grids;
        frameStr = parts[3] || ''; // Assume legacy has frame data in parts[3]
      }
      const frameRuns = frameStr.split(';');
      const totalFrames = frameRuns.length;
      let decodedFrames = [];
      for (let f = 0; f < totalFrames; f++) {
        const runStr = frameRuns[f];
        const frame = new Array(gridW * gridH).fill(0);
        let pos = 0;
        if (runStr) {
          runStr.split(',').forEach(rle => {
            const [valStr, cntStr] = rle.split(':');
            const val = parseInt(valStr);
            const cnt = parseInt(cntStr);
            for (let j = 0; j < cnt && pos < frame.length; j++) {
              frame[pos++] = val;
            }
          });
        }
        decodedFrames.push(frame);
        self.postMessage({ type: 'decodeProgress', data: { current: f + 1, total: totalFrames } });
      }
      self.postMessage({ type: 'decoded', data: { atlas, ci, frames: decodedFrames, logicalWidth, logicalHeight, gridW, gridH } });
    } catch (err) {
      self.postMessage({ type: 'error', data: err.message });
    }
  }
};
`;
const blob = new Blob([workerScript], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(blob);
worker = new Worker(workerUrl);

function updateActiveButton() {
  document.querySelectorAll('#toolbar button').forEach(btn => btn.classList.remove('active'));
  if (mode === 'pan') {
    document.getElementById('panBtn').classList.add('active');
  } else if (mode === 'pick') {
    document.getElementById('pickBtn').classList.add('active');
  } else {
    if (brush) {
      document.getElementById('b').classList.add('active');
    } else {
      document.getElementById('e').classList.add('active');
    }
  }
}

function updateStatus() {
  document.getElementById('frameCount').textContent = `Frame: ${cur + 1}/${frames.length}`;
  document.getElementById('fpsDisplay').textContent = `${fps} FPS`;
  document.getElementById('zoomDisplay').textContent = `${Math.round(zoom * 100)}%`;
}

function updateCanvasSize() {
  const containerW = container.clientWidth;
  const containerH = container.clientHeight;
  const fitScale = Math.min(containerW / logicalWidth, containerH / logicalHeight);
  cssWidth = logicalWidth * fitScale;
  cssHeight = logicalHeight * fitScale;
  const dpr = window.devicePixelRatio || 1;
  const pixelW = Math.floor(cssWidth * dpr);
  const pixelH = Math.floor(cssHeight * dpr);
  can.width = pixelW;
  can.height = pixelH;
  can.style.width = `${cssWidth}px`;
  can.style.height = `${cssHeight}px`;
  requestRender();
}

function requestRender() {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(render);
}

function renderFrameToOffscreen() {
  if (!frames[cur] || !Array.isArray(frames[cur]) || frames[cur].length !== gridW * gridH) {
    return;
  }
  const imageData = offscreenCtx.createImageData(logicalWidth, logicalHeight);
  const data = imageData.data;
  const pixelW = logicalWidth / gridW;
  const pixelH = logicalHeight / gridH;
  // Fill background
  const bgRGBA = hexToRGBA(bgColor);
  for (let i = 0; i < data.length; i += 4) {
    data[i] = bgRGBA[0];
    data[i+1] = bgRGBA[1];
    data[i+2] = bgRGBA[2];
    data[i+3] = bgRGBA[3];
  }
  // Draw pixels
  for (let i = 0; i < frames[cur].length; i++) {
    const v = frames[cur][i];
    if (v !== 0) {
      const rgba = paletteRGBA[v];
      const x = (i % gridW) * pixelW;
      const y = Math.floor(i / gridW) * pixelH;
      for (let py = 0; py < pixelH; py++) {
        for (let px = 0; px < pixelW; px++) {
          const idx = ((y + py) * logicalWidth + (x + px)) * 4;
          data[idx] = rgba[0];
          data[idx+1] = rgba[1];
          data[idx+2] = rgba[2];
          data[idx+3] = rgba[3];
        }
      }
    }
  }
  offscreenCtx.putImageData(imageData, 0, 0);
  // Draw dashed border
  const borderColor = invertColor(bgColor);
  offscreenCtx.strokeStyle = borderColor;
  offscreenCtx.lineWidth = 1;
  offscreenCtx.setLineDash([2, 2]);
  offscreenCtx.strokeRect(0, 0, logicalWidth, logicalHeight);
  offscreenCtx.setLineDash([]);
}

function render() {
  rafId = 0;
  if (dirtyFrame) {
    renderFrameToOffscreen();
    dirtyFrame = false;
  }
  const dpr = window.devicePixelRatio || 1;
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, can.width, can.height);
  ctx.save();
  ctx.translate(can.width / 2, can.height / 2);
  const scaleX = (can.width / logicalWidth) * zoom;
  const scaleY = (can.height / logicalHeight) * zoom;
  ctx.scale(scaleX, scaleY);
  ctx.translate(-panX, -panY);
  ctx.drawImage(offscreenCanvas, 0, 0);
  ctx.restore();
  ctx.imageSmoothingEnabled = false;
}

function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

function updateFrames() {
  const fdiv = document.getElementById('frames');
  fdiv.innerHTML = '';
  frames.forEach((f, i) => {
    if (!Array.isArray(f)) return;
    const container = document.createElement('div');
    container.className = 'frame-container';
    const thumb = document.createElement('canvas');
    thumb.width = thumb.height = 40;
    thumb.className = `frame ${i === cur ? 'active' : ''}`;
    const tctx = thumb.getContext('2d');
    tctx.imageSmoothingEnabled = false;
    const thumbImageData = tctx.createImageData(40, 40);
    const thumbData = thumbImageData.data;
    const bgRGBA = hexToRGBA(bgColor);
    for (let j = 0; j < thumbData.length; j += 4) {
      thumbData[j] = bgRGBA[0];
      thumbData[j+1] = bgRGBA[1];
      thumbData[j+2] = bgRGBA[2];
      thumbData[j+3] = bgRGBA[3];
    }
    // Downsampled thumb
    const thumbW = 40, thumbH = 40;
    const sampleW = Math.max(1, gridW / thumbW);
    const sampleH = Math.max(1, gridH / thumbH);
    for (let ty = 0; ty < thumbH; ty++) {
      for (let tx = 0; tx < thumbW; tx++) {
        const sx = Math.floor(tx * sampleW);
        const sy = Math.floor(ty * sampleH);
        const v = f[sy * gridW + sx];
        if (v !== 0) {
          const rgba = paletteRGBA[v];
          const idx = (ty * 40 + tx) * 4;
          thumbData[idx] = rgba[0];
          thumbData[idx+1] = rgba[1];
          thumbData[idx+2] = rgba[2];
          thumbData[idx+3] = rgba[3];
        }
      }
    }
    tctx.putImageData(thumbImageData, 0, 0);
    const label = document.createElement('div');
    label.className = 'frame-label';
    label.textContent = i + 1;
    container.appendChild(thumb);
    container.appendChild(label);
    thumb.onclick = () => {
      cur = i;
      dirtyFrame = true;
      requestRender();
      updateFrames();
      updateStatus();
    };
    fdiv.appendChild(container);
  });
  updateCurrentThumb();
}

function updateCurrentThumb() {
  const fdiv = document.getElementById('frames');
  const containers = fdiv.querySelectorAll('.frame-container');
  if (containers[cur]) {
    const thumb = containers[cur].querySelector('canvas');
    const tctx = thumb.getContext('2d');
    tctx.imageSmoothingEnabled = false;
    const thumbImageData = tctx.createImageData(40, 40);
    const thumbData = thumbImageData.data;
    const bgRGBA = hexToRGBA(bgColor);
    for (let j = 0; j < thumbData.length; j += 4) {
      thumbData[j] = bgRGBA[0];
      thumbData[j+1] = bgRGBA[1];
      thumbData[j+2] = bgRGBA[2];
      thumbData[j+3] = bgRGBA[3];
    }
    const thumbW = 40, thumbH = 40;
    const sampleW = Math.max(1, gridW / thumbW);
    const sampleH = Math.max(1, gridH / thumbH);
    for (let ty = 0; ty < thumbH; ty++) {
      for (let tx = 0; tx < thumbW; tx++) {
        const sx = Math.floor(tx * sampleW);
        const sy = Math.floor(ty * sampleH);
        const v = frames[cur][sy * gridW + sx];
        if (v !== 0) {
          const rgba = paletteRGBA[v];
          const idx = (ty * 40 + tx) * 4;
          thumbData[idx] = rgba[0];
          thumbData[idx+1] = rgba[1];
          thumbData[idx+2] = rgba[2];
          thumbData[idx+3] = rgba[3];
        }
      }
    }
    tctx.putImageData(thumbImageData, 0, 0);
  }
}

function saveHistory() {
  history.push(structuredClone(frames));
  if (history.length > 20) history.shift();
  future = [];
}

function getColorIndex(hex) {
  if (ci[hex] !== undefined) return ci[hex];
  const index = atlas.length;
  atlas.push(hex);
  ci[hex] = index;
  updatePalette();
  return index;
}

function getLogicalPos(e) {
  const rect = can.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const scaleX = (cssWidth / logicalWidth) * zoom;
  const scaleY = (cssHeight / logicalHeight) * zoom;
  const lx = ((mx - cssWidth / 2) / scaleX) + panX;
  const ly = ((my - cssHeight / 2) / scaleY) + panY;
  const gx = Math.floor(lx / (logicalWidth / gridW));
  const gy = Math.floor(ly / (logicalHeight / gridH));
  return { x: gx, y: gy };
}

can.onmousedown = (e) => {
  if (!currentProjectId && (mode === 'draw' || mode === 'pick')) {
    alert('Select a project to draw. Go to the projects menu to load or create one.');
    return;
  }
  const pos = getLogicalPos(e);
  const { x, y } = pos;
  if (mode === 'pan') {
    isPanning = true;
    startX = e.clientX;
    startY = e.clientY;
    startPanX = panX;
    startPanY = panY;
  } else if (mode === 'pick') {
    if (x >= 0 && x < gridW && y >= 0 && y < gridH) {
      const idx = y * gridW + x;
      const v = frames[cur][idx];
      if (v !== 0) {
        color = atlas[v];
        document.getElementById('c').value = color;
      }
    }
  } else {
    if (x >= 0 && x < gridW && y >= 0 && y < gridH) {
      drawing = true;
      saveHistory();
      drawPixel(x, y);
    }
  }
};

can.onmousemove = (e) => {
  if (drawing && !currentProjectId) return;
  if (isPanning) {
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    const scaleX = (cssWidth / logicalWidth) * zoom;
    const scaleY = (cssHeight / logicalHeight) * zoom;
    panX = startPanX - dx / scaleX;
    panY = startPanY - dy / scaleY;
    requestRender();
  } else if (drawing) {
    const pos = getLogicalPos(e);
    const { x, y } = pos;
    if (x >= 0 && x < gridW && y >= 0 && y < gridH) {
      drawPixel(x, y);
    }
  }
};

can.onmouseup = can.onmouseleave = () => {
  isPanning = false;
  drawing = false;
};

can.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = can.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const oldZoom = zoom;
  zoom *= (e.deltaY > 0 ? 0.9 : 1.1);
  const scaleX_old = (cssWidth / logicalWidth) * oldZoom;
  const scaleY_old = (cssHeight / logicalHeight) * oldZoom;
  const lx = ((mx - cssWidth / 2) / scaleX_old) + panX;
  const ly = ((my - cssHeight / 2) / scaleY_old) + panY;
  const scaleX_new = (cssWidth / logicalWidth) * zoom;
  const scaleY_new = (cssHeight / logicalHeight) * zoom;
  panX = lx - ((mx - cssWidth / 2) / scaleX_new);
  panY = ly - ((my - cssHeight / 2) / scaleY_new);
  requestRender();
  updateStatus();
});

function drawPixel(gx, gy) {
  if (!currentProjectId) return;
  const h = Math.floor(size / 2);
  let changed = false;
  for (let dx = -h; dx <= h; dx++) {
    for (let dy = -h; dy <= h; dy++) {
      const px = gx + dx;
      const py = gy + dy;
      if (px >= 0 && px < gridW && py >= 0 && py < gridH) {
        const idx = py * gridW + px;
        const oldV = frames[cur][idx];
        const newV = brush ? getColorIndex(color) : 0;
        if (oldV !== newV) {
          frames[cur][idx] = newV;
          changed = true;
        }
      }
    }
  }
  if (changed) {
    dirtyFrame = true;
    updateCurrentThumb();
    requestRender();
  }
}

document.getElementById('b').onclick = () => { brush = true; updateActiveButton(); };
document.getElementById('e').onclick = () => { brush = false; updateActiveButton(); };
document.getElementById('panBtn').onclick = () => { mode = mode === 'pan' ? 'draw' : 'pan'; updateActiveButton(); };
document.getElementById('pickBtn').onclick = () => { mode = mode === 'pick' ? 'draw' : 'pick'; updateActiveButton(); };
document.getElementById('c').oninput = (e) => { 
  color = e.target.value;
  updatePalette();
  dirtyFrame = true;
  requestRender();
};
document.getElementById('bg').oninput = (e) => { 
  bgColor = e.target.value; 
  dirtyFrame = true;
  requestRender();
  updateFrames(); 
};
document.getElementById('s').oninput = (e) => size = parseInt(e.target.value);
document.getElementById('d').onclick = () => {
  if (!currentProjectId) {
    alert('Select a project to draw. Go to the projects menu to load or create one.');
    return;
  }
  saveHistory();
  frames[cur].fill(0);
  dirtyFrame = true;
  updateCurrentThumb();
  requestRender();
};
document.getElementById('a').onclick = () => {
  if (!currentProjectId) {
    alert('Select a project to draw. Go to the projects menu to load or create one.');
    return;
  }
  const copy = confirm('Copy current frame to new frame?');
  const newFrame = copy ? [...frames[cur]] : new Array(gridW * gridH).fill(0);
  frames.push(newFrame);
  cur = frames.length - 1;
  updateFrames();
  dirtyFrame = true;
  requestRender();
  updateStatus();
};
document.getElementById('r').onclick = () => {
  if (!currentProjectId || frames.length <= 1) {
    alert('Select a project to draw. Go to the projects menu to load or create one.');
    return;
  }
  frames.splice(cur, 1);
  cur = Math.max(0, cur - 1);
  updateFrames();
  dirtyFrame = true;
  requestRender();
  updateStatus();
};
document.getElementById('u').onclick = () => {
  if (!currentProjectId || !history.length) {
    alert('Select a project to draw. Go to the projects menu to load or create one.');
    return;
  }
  future.push(structuredClone(frames));
  frames = history.pop();
  cur = Math.min(cur, frames.length - 1);
  updateCurrentThumb();
  dirtyFrame = true;
  requestRender();
  updateStatus();
};
document.getElementById('redo').onclick = () => {
  if (!currentProjectId || !future.length) {
    alert('Select a project to draw. Go to the projects menu to load or create one.');
    return;
  }
  history.push(structuredClone(frames));
  frames = future.pop();
  cur = Math.min(cur, frames.length - 1);
  updateCurrentThumb();
  dirtyFrame = true;
  requestRender();
  updateStatus();
};

document.getElementById('saveBtn').onclick = async () => {
  if (!currentProjectId) {
    alert('No project selected. Load a project to save.');
    return;
  }
  try {
    await updateProject(currentProjectId, getProjectData());
    document.getElementById('statusText').textContent = 'Project saved';
    setTimeout(() => { document.getElementById('statusText').textContent = 'Ready to draw'; }, 1000);
  } catch (e) {
    alert('Error saving project: ' + e.message);
  }
};

document.getElementById('fpsInput').oninput = (e) => {
  fps = parseInt(e.target.value) || 5;
  frameInterval = 1000 / fps;
  updateStatus();
};

document.getElementById('projectsBtn').onclick = async () => {
  modal.style.display = 'flex';
  await populateProjects();
};

document.getElementById('guideBtn').onclick = () => {
  guideModal.style.display = 'flex';
};

document.getElementById('newProjBtn').onclick = async () => {
  const name = prompt('Project name:');
  if (!name) return;
  const wStr = prompt('Width (px):', '320');
  if (!wStr) return;
  const hStr = prompt('Height (px):', '320');
  if (!hStr) return;
  const width = parseInt(wStr);
  const height = parseInt(hStr);
  if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
    alert('Invalid dimensions');
    return;
  }
  logicalWidth = width;
  logicalHeight = height;
  gridW = width;
  gridH = height;
  frames = [new Array(gridW * gridH).fill(0)];
  atlas = ["t"];
  ci = {"transparent": 0};
  cur = 0;
  history = [];
  future = [];
  panX = logicalWidth / 2;
  panY = logicalHeight / 2;
  zoom = 1;
  document.getElementById('zoomDisplay').textContent = '100%';
  updatePalette();
  initOffscreen();
  updateCanvasSize();
  updateFrames();
  dirtyFrame = true;
  requestRender();
  updateStatus();
  document.getElementById('statusText').textContent = 'Saving new project...';
  try {
    const id = await saveProject(name, getProjectData());
    currentProjectId = id;
    if (autoSaveInterval) clearInterval(autoSaveInterval);
    autoSaveInterval = setInterval(async () => {
      if (!currentProjectId) return;
      try {
        await updateProject(currentProjectId, getProjectData());
        document.getElementById('statusText').textContent = 'Auto-saved';
        setTimeout(() => { document.getElementById('statusText').textContent = 'Ready to draw'; }, 1000);
      } catch (e) {
        console.error('Auto-save failed:', e);
      }
    }, 5000);
    modal.style.display = 'none';
    await populateProjects();
    document.getElementById('statusText').textContent = 'Ready to draw';
  } catch (e) {
    alert('Error saving project: ' + e.message);
  }
};

document.getElementById('closeModal').onclick = () => {
  modal.style.display = 'none';
};

document.getElementById('closeGuide').onclick = () => {
  guideModal.style.display = 'none';
};

worker.onmessage = function(e) {
  const { type, data } = e.data;
  if (type === 'encoded') {
    const blob = new Blob([data], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'anim.pxanim';
    a.click();
    URL.revokeObjectURL(a.href);
  } else if (type === 'decoded') {
    const { atlas: newAtlas, ci: newCi, frames: newFrames, logicalWidth: newLW, logicalHeight: newLH, gridW: newGW, gridH: newGH } = data;
    if (currentProjectId) {
      atlas = newAtlas;
      ci = newCi;
      frames = newFrames;
      logicalWidth = newLW;
      logicalHeight = newLH;
      gridW = newGW;
      gridH = newGH;
      panX = logicalWidth / 2;
      panY = logicalHeight / 2;
      zoom = 1;
      document.getElementById('zoomDisplay').textContent = '100%';
      updatePalette();
      initOffscreen();
      updateCanvasSize();
      cur = 0;
      updateFrames();
      dirtyFrame = true;
      requestRender();
      history = [];
      future = [];
      updateStatus();
    }
    const progressContainer = document.getElementById('progressContainer');
    progressContainer.style.display = 'none';
    document.getElementById('statusText').textContent = 'Ready to draw';
  } else if (type === 'decodeProgress') {
    const { current, total } = data;
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    if (progressBar && progressText) {
      progressBar.value = (current / total) * 100;
      progressText.textContent = `${current}/${total} frames`;
    }
  } else if (type === 'error') {
    alert('Error: ' + data);
    const progressContainer = document.getElementById('progressContainer');
    if (progressContainer) progressContainer.style.display = 'none';
    document.getElementById('statusText').textContent = 'Ready to draw';
  }
};

document.getElementById('exp').onclick = () => {
  if (!currentProjectId) {
    alert('No project selected.');
    return;
  }
  worker.postMessage({ type: 'encode', data: { atlas, frames, logicalWidth, logicalHeight, gridW, gridH } });
};

document.getElementById('impBtn').onclick = () => document.getElementById('impFile').click();
document.getElementById('impFile').onchange = (e) => {
  const file = e.target.files[0];
  if (file) {
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    if (progressContainer && progressBar && progressText) {
      progressContainer.style.display = 'flex';
      progressBar.value = 0;
      progressText.textContent = '0 frames';
    }
    document.getElementById('statusText').textContent = 'Decoding file...';
    const reader = new FileReader();
    reader.onload = (ev) => {
      worker.postMessage({ type: 'decode', data: { encoded: ev.target.result } });
    };
    reader.readAsText(file);
  }
};

document.getElementById('p').onclick = () => {
  if (!currentProjectId) {
    alert('No project selected.');
    return;
  }
  const indicator = document.getElementById('playingIndicator');
  const playBtn = document.getElementById('p');
  if (playI) {
    clearInterval(playI);
    playI = null;
    indicator.style.display = 'none';
    playBtn.innerHTML = '<i class="fas fa-play"></i>';
    return;
  }
  let i = 0;
  playI = setInterval(() => {
    i = (i + 1) % frames.length;
    cur = i;
    dirtyFrame = true;
    updateCurrentThumb();
    requestRender();
    updateStatus();
  }, frameInterval);
  indicator.style.display = 'inline';
  playBtn.innerHTML = '<i class="fas fa-pause"></i>';
};

updatePalette();
initOffscreen();
updateCanvasSize();
updateFrames();
requestRender();
updateActiveButton();
updateStatus();
document.getElementById('projectsBtn').click();
window.addEventListener('resize', updateCanvasSize);
</script>
</body>
</html>
