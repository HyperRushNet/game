<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Animator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <style>
        canvas {
            image-rendering: pixelated;
        }
        #overlayCanvas {
            opacity: 0.5;
            pointer-events: none;
        }
        .toggle-btn.active {
            background-color: #2563eb;
            color: white;
        }
        #projectList {
            max-height: 120px;
            overflow-y: auto;
        }
        .project-item.selected {
            background-color: #2563eb;
            color: white;
        }
        .project-item:hover:not(.selected) {
            background-color: #e5e7eb;
        }
        #colorList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 120px;
            overflow-y: auto;
        }
        .color-card {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            cursor: pointer;
            position: relative;
        }
        .color-card:hover {
            border-color: #2563eb;
        }
        .color-card span {
            font-size: 12px;
            color: white;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
            text-align: center;
            word-break: break-all;
        }
        .color-card button {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #dc2626;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1;
            padding: 0;
        }
        #exportString {
            width: 100%;
            min-height: 60px;
            resize: vertical;
        }
        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #modalContent {
            background: white;
            border-radius: 8px;
            padding: 20px;
            position: relative;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
        }
        #modalClose {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc2626;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
        }
        #previewCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.3;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4 font-sans">
    <div class="bg-white rounded-lg shadow-lg p-6 max-w-3xl w-full">
        <h1 class="text-2xl font-bold text-gray-800 mb-4 text-center">Pixel Animator</h1>
        <div class="mb-6 border border-gray-200 rounded-md p-4 bg-gray-50">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">
                Projectbeheer: <span id="currentProjectName" class="text-blue-600">Geen project geselecteerd</span>
            </h2>
            <div class="flex gap-2 mb-3">
                <input type="text" id="newProjectName" placeholder="Projectnaam" maxlength="30" class="border border-gray-300 rounded-md px-3 py-2 w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                <input type="file" id="imageUpload" accept="image/*" class="border border-gray-300 rounded-md px-3 py-2 text-gray-700">
                <button id="createProject" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Nieuw Project</button>
            </div>
            <div class="flex gap-2 mb-3">
                <button id="exportProject" class="bg-teal-600 text-white px-4 py-2 rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 transition">Exporteer Project</button>
                <input type="text" id="importString" placeholder="Plak projectstring" class="border border-gray-300 rounded-md px-3 py-2 w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="importProject" class="bg-teal-600 text-white px-4 py-2 rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 transition">Importeer Project</button>
            </div>
            <textarea id="exportString" readonly class="border border-gray-300 rounded-md px-3 py-2 text-gray-700 mb-3" placeholder="Projectstring verschijnt hier na export"></textarea>
            <div id="canvasInfo" class="text-sm text-gray-600 mb-2"></div>
            <div id="projectList" class="border border-gray-200 rounded-md p-2 bg-white">
                <p id="noProjects" class="text-gray-500 text-sm text-center">Geen projecten beschikbaar</p>
            </div>
        </div>
        <div id="canvasWrapper" class="relative mx-auto mb-6 border border-gray-300 rounded-md overflow-hidden bg-white">
            <canvas id="mainCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
            <canvas id="overlayCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
            <canvas id="previewCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
        </div>
        <div class="grid grid-cols-1 gap-4">
            <div class="flex justify-center items-center gap-3 flex-wrap">
                <input type="color" id="colorPicker" value="#000000" class="w-10 h-10 rounded-md cursor-pointer border border-gray-300">
                <button id="drawMode" class="toggle-btn bg-gray-200 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition active">Tekenen</button>
                <button id="eraseMode" class="toggle-btn bg-gray-200 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Gommen</button>
                <button id="pickMode" class="toggle-btn bg-gray-200 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Kleurkiezer</button>
                <select id="mirrorMode" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="none">Geen spiegeling</option>
                    <option value="horizontal">Horizontaal (X-as)</option>
                    <option value="vertical">Verticaal (Y-as)</option>
                    <option value="both">Beide (X+Y-as)</option>
                </select>
                <label class="flex items-center gap-2 text-gray-700">
                    <input type="checkbox" id="overlayToggle" checked class="h-5 w-5 rounded focus:ring-blue-500">
                    Overlay
                </label>
                <label class="flex items-center gap-2 text-gray-700">
                    <input type="checkbox" id="crosshairToggle" checked class="h-5 w-5 rounded focus:ring-blue-500">
                    Kruislijnen
                </label>
                <select id="brushSize" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="1">1x1</option>
                    <option value="3">3x3</option>
                    <option value="5">5x5</option>
                    <option value="7">7x7</option>
                </select>
            </div>
            <div class="flex justify-center gap-2 flex-wrap">
                <input type="text" id="colorName" placeholder="Kleurnaam" maxlength="20" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="saveColor" class="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 transition">Kleur Opslaan</button>
            </div>
            <div id="colorList" class="border border-gray-200 rounded-md p-2 bg-white"></div>
            <div class="flex justify-center gap-2 flex-wrap">
                <button id="playAnimation" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition">Speel Animatie</button>
                <button id="newFrame" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Nieuw Frame</button>
                <button id="prevFrame" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition">Vorige</button>
                <button id="nextFrame" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition">Volgende</button>
                <button id="deleteFrame" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 transition">Verwijder Frame</button>
                <button id="deleteAllFrames" class="bg-red-800 text-white px-4 py-2 rounded-md hover:bg-red-900 focus:outline-none focus:ring-2 focus:ring-red-500 transition">Verwijder Alles</button>
                <button id="exportVideo" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition">Exporteer Video</button>
            </div>
            <div id="frameInfo" class="text-center text-lg font-semibold text-gray-800">Geen project geselecteerd</div>
        </div>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
        const overlayCtx = overlayCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const drawModeBtn = document.getElementById('drawMode');
        const eraseModeBtn = document.getElementById('eraseMode');
        const pickModeBtn = document.getElementById('pickMode');
        const mirrorModeSelect = document.getElementById('mirrorMode');
        const overlayToggle = document.getElementById('overlayToggle');
        const crosshairToggle = document.getElementById('crosshairToggle');
        const brushSizeSelect = document.getElementById('brushSize');
        const newFrameBtn = document.getElementById('newFrame');
        const prevFrameBtn = document.getElementById('prevFrame');
        const nextFrameBtn = document.getElementById('nextFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const deleteAllFramesBtn = document.getElementById('deleteAllFrames');
        const exportVideoBtn = document.getElementById('exportVideo');
        const playAnimationBtn = document.getElementById('playAnimation');
        const frameInfo = document.getElementById('frameInfo');
        const newProjectName = document.getElementById('newProjectName');
        const imageUpload = document.getElementById('imageUpload');
        const createProjectBtn = document.getElementById('createProject');
        const exportProjectBtn = document.getElementById('exportProject');
        const importStringInput = document.getElementById('importString');
        const importProjectBtn = document.getElementById('importProject');
        const exportStringTextarea = document.getElementById('exportString');
        const projectList = document.getElementById('projectList');
        const noProjects = document.getElementById('noProjects');
        const currentProjectName = document.getElementById('currentProjectName');
        const canvasInfo = document.getElementById('canvasInfo');
        const colorNameInput = document.getElementById('colorName');
        const saveColorBtn = document.getElementById('saveColor');
        const colorList = document.getElementById('colorList');

        let projects = JSON.parse(localStorage.getItem('pixelAnimatorProjects')) || {};
        let currentProject = null;
        let frames = [];
        let currentFrame = 0;
        let isDrawing = false;
        let mode = 'drawing';
        let canvasWidth = 100;
        let canvasHeight = 100;
        let brushSize = 1;

        // Teken grid en kruislijnen
        function drawGuides() {
            mainCtx.strokeStyle = '#d3d3d3';
            mainCtx.lineWidth = 0.1;
            for (let x = 0; x <= canvasWidth; x++) {
                mainCtx.beginPath();
                mainCtx.moveTo(x, 0);
                mainCtx.lineTo(x, canvasHeight);
                mainCtx.stroke();
            }
            for (let y = 0; y <= canvasHeight; y++) {
                mainCtx.beginPath();
                mainCtx.moveTo(0, y);
                mainCtx.lineTo(canvasWidth, y);
                mainCtx.stroke();
            }
            if (crosshairToggle.checked) {
                mainCtx.strokeStyle = '#d3d3d3';
                mainCtx.lineWidth = 0.5;
                mainCtx.beginPath();
                mainCtx.moveTo(canvasWidth / 2, 0);
                mainCtx.lineTo(canvasWidth / 2, canvasHeight);
                mainCtx.stroke();
                mainCtx.beginPath();
                mainCtx.moveTo(0, canvasHeight / 2);
                mainCtx.lineTo(canvasWidth, canvasHeight / 2);
                mainCtx.stroke();
            }
        }

        // Update canvas en overlay
        function updateCanvas(clearPreview = true) {
            if (!currentProject) {
                mainCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                frameInfo.textContent = 'Geen project geselecteerd';
                currentProjectName.textContent = 'Geen project geselecteerd';
                canvasInfo.textContent = '';
                colorList.innerHTML = '';
                exportStringTextarea.value = '';
                disableControls(true);
                return;
            }
            disableControls(false);
            mainCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            mainCtx.putImageData(frames[currentFrame], 0, 0);
            drawGuides();
            overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (overlayToggle.checked && currentFrame > 0) {
                overlayCtx.putImageData(frames[currentFrame - 1], 0, 0);
            }
            if (clearPreview) {
                previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            }
            frameInfo.textContent = `Frame ${currentFrame + 1} / ${frames.length}`;
            currentProjectName.textContent = currentProject;
            canvasInfo.textContent = `Canvas: ${canvasWidth}x${canvasHeight} pixels`;
            updateColorList();
            exportStringTextarea.value = '';
            deleteFrameBtn.disabled = frames.length <= 1;
            deleteAllFramesBtn.disabled = frames.length <= 1;
            saveCurrentProject();
        }

        // Schakel controls in/uit
        function disableControls(disabled) {
            [newFrameBtn, prevFrameBtn, nextFrameBtn, deleteFrameBtn, deleteAllFramesBtn, exportVideoBtn, playAnimationBtn, exportProjectBtn, importProjectBtn, colorPicker, drawModeBtn, eraseModeBtn, pickModeBtn, overlayToggle, mirrorModeSelect, crosshairToggle, saveColorBtn, colorNameInput, brushSizeSelect].forEach(el => {
                el.disabled = disabled;
                el.classList.toggle('opacity-50', disabled);
                el.classList.toggle('cursor-not-allowed', disabled);
            });
        }

        // Haal pixels voor brush
        function getBrushPixels(centerX, centerY) {
            const half = Math.floor(brushSize / 2);
            const pixels = [];
            for (let dx = -half; dx <= half; dx++) {
                for (let dy = -half; dy <= half; dy++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight) {
                        pixels.push({ x, y });
                    }
                }
            }
            return pixels;
        }

        // Pas mirror toe op lijst van pixels
        function applyMirror(pixels) {
            const mirrorMode = mirrorModeSelect.value;
            const mirroredPixels = [...pixels];
            pixels.forEach(({ x, y }) => {
                if (mirrorMode === 'horizontal' || mirrorMode === 'both') {
                    const mx = canvasWidth - x - 1;
                    if (mx !== x || mirrorMode === 'both') mirroredPixels.push({ x: mx, y });
                }
                if (mirrorMode === 'vertical' || mirrorMode === 'both') {
                    const my = canvasHeight - y - 1;
                    if (my !== y || mirrorMode === 'both') mirroredPixels.push({ x, y: my });
                }
                if (mirrorMode === 'both') {
                    const mx = canvasWidth - x - 1;
                    const my = canvasHeight - y - 1;
                    if (mx !== x || my !== y) mirroredPixels.push({ x: mx, y: my });
                }
            });
            // Verwijder duplicaten
            return [...new Set(mirroredPixels.map(p => `${p.x},${p.y}`))].map(str => {
                const [x, y] = str.split(',').map(Number);
                return { x, y };
            });
        }

        // Teken preview
        function drawPreview(x, y) {
            if (!currentProject || mode === 'picking') return;
            previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            const centerX = Math.floor(x);
            const centerY = Math.floor(y);
            if (centerX < 0 || centerX >= canvasWidth || centerY < 0 || centerY >= canvasHeight) return;

            let brushPixels = getBrushPixels(centerX, centerY);
            brushPixels = applyMirror(brushPixels);

            const color = mode === 'erasing' ? '#FFFFFF' : colorPicker.value;
            previewCtx.fillStyle = color;
            brushPixels.forEach(({ x, y }) => {
                previewCtx.fillRect(x, y, 1, 1);
            });
        }

        // Teken, wis of kies kleur
        function modifyPixels(centerX, centerY) {
            if (!currentProject) return;
            const centerXFloor = Math.floor(centerX);
            const centerYFloor = Math.floor(centerY);
            if (centerXFloor < 0 || centerXFloor >= canvasWidth || centerYFloor < 0 || centerYFloor >= canvasHeight) return;

            if (mode === 'picking') {
                const pixel = mainCtx.getImageData(centerXFloor, centerYFloor, 1, 1).data;
                if (pixel[3] !== 0) {
                    colorPicker.value = rgbToHex(pixel[0], pixel[1], pixel[2]);
                }
                return;
            }

            let brushPixels = getBrushPixels(centerXFloor, centerYFloor);
            brushPixels = applyMirror(brushPixels);

            const frameData = frames[currentFrame].data;
            brushPixels.forEach(({ x, y }) => {
                const index = (y * canvasWidth + x) * 4;
                if (mode === 'drawing') {
                    const { r, g, b } = hexToRgb(colorPicker.value);
                    frameData[index] = r;
                    frameData[index + 1] = g;
                    frameData[index + 2] = b;
                    frameData[index + 3] = 255;
                } else if (mode === 'erasing') {
                    frameData[index] = frameData[index + 1] = frameData[index + 2] = frameData[index + 3] = 0;
                }
            });
            updateCanvas(false); // Houd preview niet wissen bij tekenen
        }

        // Converteer RGB naar hex
        function rgbToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0')}`;
        }

        // Converteer hex naar RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        // Kleurenbeheer
        function updateColorList() {
            colorList.innerHTML = '';
            if (currentProject && projects[currentProject].colors) {
                projects[currentProject].colors.forEach((color, index) => {
                    const card = document.createElement('div');
                    card.className = 'color-card';
                    card.style.backgroundColor = color.hex;
                    card.innerHTML = `<span>${color.name}</span><button>X</button>`;
                    card.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'BUTTON') {
                            colorPicker.value = color.hex;
                        }
                    });
                    card.querySelector('button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        projects[currentProject].colors.splice(index, 1);
                        saveCurrentProject();
                        updateColorList();
                    });
                    colorList.appendChild(card);
                });
            }
        }

        saveColorBtn.addEventListener('click', () => {
            if (!currentProject) return;
            const name = colorNameInput.value.trim().replace(/[^a-zA-Z0-9-_ ]/g, '');
            const hex = colorPicker.value;
            if (name && !projects[currentProject].colors?.some(c => c.hex === hex)) {
                projects[currentProject].colors = projects[currentProject].colors || [];
                projects[currentProject].colors.push({ name, hex });
                saveCurrentProject();
                updateColorList();
                colorNameInput.value = '';
            }
        });

        // Projectbeheer
        function saveCurrentProject() {
            if (currentProject) {
                projects[currentProject] = {
                    frames: frames.map(frame => Array.from(frame.data)),
                    currentFrame,
                    width: canvasWidth,
                    height: canvasHeight,
                    colors: projects[currentProject]?.colors || []
                };
                localStorage.setItem('pixelAnimatorProjects', JSON.stringify(projects));
            }
        }

        function loadProject(name) {
            currentProject = name;
            const project = projects[name];
            canvasWidth = project.width;
            canvasHeight = project.height;
            mainCanvas.width = overlayCanvas.width = previewCanvas.width = canvasWidth;
            mainCanvas.height = overlayCanvas.height = previewCanvas.height = canvasHeight;
            canvasWrapper.style.width = `${canvasWidth * 6}px`;
            canvasWrapper.style.height = `${canvasHeight * 6}px`;
            mainCanvas.style.width = `${canvasWidth * 6}px`;
            mainCanvas.style.height = `${canvasHeight * 6}px`;
            overlayCanvas.style.width = `${canvasWidth * 6}px`;
            overlayCanvas.style.height = `${canvasHeight * 6}px`;
            previewCanvas.style.width = `${canvasWidth * 6}px`;
            previewCanvas.style.height = `${canvasHeight * 6}px`;
            frames = project.frames.map(data => {
                const imgData = mainCtx.createImageData(canvasWidth, canvasHeight);
                imgData.data.set(new Uint8ClampedArray(data));
                return imgData;
            });
            currentFrame = Math.min(project.currentFrame || 0, frames.length - 1);
            updateCanvas();
            updateProjectList();
        }

        function updateProjectList() {
            projectList.innerHTML = '';
            if (!Object.keys(projects).length) {
                noProjects.style.display = 'block';
                return;
            }
            noProjects.style.display = 'none';
            Object.keys(projects).forEach(name => {
                const div = document.createElement('div');
                div.className = `flex justify-between items-center p-2 rounded-md cursor-pointer project-item ${currentProject === name ? 'selected' : ''}`;
                div.innerHTML = `<span>${name}</span><button class="text-red-600 hover:text-red-800 text-sm">Verwijder</button>`;
                div.querySelector('button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    delete projects[name];
                    localStorage.setItem('pixelAnimatorProjects', JSON.stringify(projects));
                    if (currentProject === name) {
                        currentProject = null;
                        frames = [];
                        currentFrame = 0;
                        canvasWidth = canvasHeight = 100;
                        mainCanvas.width = overlayCanvas.width = previewCanvas.width = canvasWidth;
                        mainCanvas.height = overlayCanvas.height = previewCanvas.height = canvasHeight;
                        canvasWrapper.style.width = canvasWrapper.style.height = `${canvasWidth * 6}px`;
                        mainCanvas.style.width = mainCanvas.style.height = `${canvasWidth * 6}px`;
                        overlayCanvas.style.width = overlayCanvas.style.height = `${canvasWidth * 6}px`;
                        previewCanvas.style.width = previewCanvas.style.height = `${canvasWidth * 6}px`;
                        updateCanvas();
                    }
                    updateProjectList();
                });
                div.addEventListener('click', () => {
                    if (currentProject !== name) loadProject(name);
                });
                projectList.appendChild(div);
            });
        }

        // Afbeelding uploaden
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const img = new Image();
            img.onload = () => {
                canvasWidth = img.width;
                canvasHeight = img.height;
                mainCanvas.width = overlayCanvas.width = previewCanvas.width = canvasWidth;
                mainCanvas.height = overlayCanvas.height = previewCanvas.height = canvasHeight;
                canvasWrapper.style.width = canvasWrapper.style.height = `${canvasWidth * 6}px`;
                mainCanvas.style.width = mainCanvas.style.height = `${canvasWidth * 6}px`;
                overlayCanvas.style.width = overlayCanvas.style.height = `${canvasWidth * 6}px`;
                previewCanvas.style.width = previewCanvas.style.height = `${canvasWidth * 6}px`;
                mainCtx.drawImage(img, 0, 0);
                frames = [mainCtx.getImageData(0, 0, canvasWidth, canvasHeight)];
                currentFrame = 0;
                if (currentProject) saveCurrentProject();
                updateCanvas();
                e.target.value = '';
            };
            img.src = URL.createObjectURL(file);
        });

        // Project exporteren/importeren
        exportProjectBtn.addEventListener('click', () => {
            if (!currentProject) return;
            const projectData = {
                name: currentProject,
                frames: frames.map(frame => Array.from(frame.data)),
                currentFrame,
                width: canvasWidth,
                height: canvasHeight,
                colors: projects[currentProject].colors || []
            };
            exportStringTextarea.value = LZString.compressToBase64(JSON.stringify(projectData));
        });

        importProjectBtn.addEventListener('click', () => {
            const str = importStringInput.value.trim();
            if (!str) return;
            try {
                const projectData = JSON.parse(LZString.decompressFromBase64(str));
                let name = projectData.name.replace(/[^a-zA-Z0-9-_]/g, '') || 'ImportedProject';
                let baseName = name;
                let counter = 1;
                while (projects[name]) name = `${baseName}_${counter++}`;
                projects[name] = {
                    frames: projectData.frames,
                    currentFrame: projectData.currentFrame || 0,
                    width: projectData.width,
                    height: projectData.height,
                    colors: projectData.colors || []
                };
                localStorage.setItem('pixelAnimatorProjects', JSON.stringify(projects));
                loadProject(name);
                importStringInput.value = '';
                updateProjectList();
            } catch (e) {
                alert('Ongeldige projectstring');
            }
        });

        createProjectBtn.addEventListener('click', () => {
            const name = newProjectName.value.trim().replace(/[^a-zA-Z0-9-_]/g, '');
            if (!name || projects[name]) return;
            projects[name] = {
                frames: frames.length ? [Array.from(frames[0].data)] : [Array.from(mainCtx.createImageData(canvasWidth, canvasHeight).data)],
                currentFrame: 0,
                width: canvasWidth,
                height: canvasHeight,
                colors: []
            };
            loadProject(name);
            newProjectName.value = '';
            updateProjectList();
        });

        // Modus schakelen
        drawModeBtn.addEventListener('click', () => {
            mode = 'drawing';
            drawModeBtn.classList.add('active');
            eraseModeBtn.classList.remove('active');
            pickModeBtn.classList.remove('active');
        });

        eraseModeBtn.addEventListener('click', () => {
            mode = 'erasing';
            eraseModeBtn.classList.add('active');
            drawModeBtn.classList.remove('active');
            pickModeBtn.classList.remove('active');
        });

        pickModeBtn.addEventListener('click', () => {
            mode = 'picking';
            pickModeBtn.classList.add('active');
            drawModeBtn.classList.remove('active');
            eraseModeBtn.classList.remove('active');
        });

        brushSizeSelect.addEventListener('change', () => {
            brushSize = parseInt(brushSizeSelect.value);
        });

        // Muis events
        mainCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = mainCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / 6;
            const y = (e.clientY - rect.top) / 6;
            modifyPixels(x, y);
        });

        mainCanvas.addEventListener('mousemove', (e) => {
            const rect = mainCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / 6;
            const y = (e.clientY - rect.top) / 6;
            if (isDrawing) {
                modifyPixels(x, y);
            } else {
                drawPreview(x, y);
            }
        });

        mainCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
            updateCanvas(); // Wis preview na tekenen
        });

        mainCanvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        });

        // Frame controls
        newFrameBtn.addEventListener('click', () => {
            if (!currentProject) return;
            const newFrame = mainCtx.createImageData(canvasWidth, canvasHeight);
            newFrame.data.set(frames[currentFrame].data); // Kopieer huidige frame
            frames.splice(currentFrame + 1, 0, newFrame); // Voeg toe na huidige frame
            currentFrame++; // Ga naar de nieuwe frame
            updateCanvas();
        });

        prevFrameBtn.addEventListener('click', () => {
            if (currentFrame > 0) {
                currentFrame--;
                updateCanvas();
            }
        });

        nextFrameBtn.addEventListener('click', () => {
            if (currentFrame < frames.length - 1) {
                currentFrame++;
                updateCanvas();
            }
        });

        deleteFrameBtn.addEventListener('click', () => {
            if (frames.length > 1) {
                frames.splice(currentFrame, 1);
                if (currentFrame >= frames.length) currentFrame = frames.length - 1;
                updateCanvas();
            }
        });

        deleteAllFramesBtn.addEventListener('click', () => {
            frames = [mainCtx.createImageData(canvasWidth, canvasHeight)];
            currentFrame = 0;
            updateCanvas();
        });

        overlayToggle.addEventListener('change', updateCanvas);
        crosshairToggle.addEventListener('change', updateCanvas);
        mirrorModeSelect.addEventListener('change', updateCanvas);

        // Video-opname zonder grid/kruislijnen
        async function recordVideo(callback) {
            if (!currentProject || !frames.length) return;
            const videoCanvas = document.createElement('canvas');
            videoCanvas.width = canvasWidth;
            videoCanvas.height = canvasHeight;
            const videoCtx = videoCanvas.getContext('2d', { willReadFrequently: true });
            const stream = videoCanvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
            const chunks = [];

            recorder.ondataavailable = (e) => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                callback(blob);
                videoCanvas.remove();
                updateCanvas();
            };

            recorder.start();
            const frameDuration = 1000 / 30;
            let frameIndex = 0;

            function renderFrame(timestamp, lastTime) {
                if (frameIndex >= frames.length) {
                    recorder.stop();
                    return;
                }
                if (!lastTime || (timestamp - lastTime) >= frameDuration) {
                    videoCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                    videoCtx.putImageData(frames[frameIndex], 0, 0);
                    frameIndex++;
                    lastTime = timestamp;
                }
                requestAnimationFrame((ts) => renderFrame(ts, lastTime));
            }

            requestAnimationFrame((ts) => renderFrame(ts, 0));
        }

        // Speel animatie
        playAnimationBtn.addEventListener('click', () => {
            recordVideo((blob) => {
                const url = URL.createObjectURL(blob);
                const modal = document.createElement('div');
                modal.id = 'modal';
                modal.innerHTML = `
                    <div id="modalContent">
                        <button id="modalClose">X</button>
                        <video controls autoplay loop style="width: ${canvasWidth * 6}px; height: ${canvasHeight * 6}px;"></video>
                    </div>
                `;
                document.body.appendChild(modal);
                const video = modal.querySelector('video');
                video.src = url;
                modal.querySelector('#modalClose').addEventListener('click', () => {
                    modal.remove();
                    URL.revokeObjectURL(url);
                });
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                        URL.revokeObjectURL(url);
                    }
                });
            });
        });

        // Exporteer video
        exportVideoBtn.addEventListener('click', () => {
            recordVideo((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentProject || 'animation'}.webm`;
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        // Initiële setup
        updateProjectList();
        if (Object.keys(projects).length) loadProject(Object.keys(projects)[0]);
        else updateCanvas();
    </script>
</body>
</html>
