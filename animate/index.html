<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Animator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <style>
        canvas {
            image-rendering: pixelated;
        }
        #overlayCanvas {
            opacity: 0.5;
            pointer-events: none;
        }
        #guidesCanvas {
            pointer-events: none;
        }
        .toggle-btn.active {
            background-color: #2563eb;
            color: white;
        }
        #projectList {
            max-height: 120px;
            overflow-y: auto;
        }
        .project-item.selected {
            background-color: #2563eb;
            color: white;
        }
        .project-item:hover:not(.selected) {
            background-color: #e5e7eb;
        }
        #colorList {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 120px;
            overflow-y: auto;
        }
        .color-card {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            cursor: pointer;
            position: relative;
        }
        .color-card:hover {
            border-color: #2563eb;
        }
        .color-card span {
            font-size: 12px;
            color: white;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
            text-align: center;
            word-break: break-all;
        }
        .color-card button {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #dc2626;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1;
            padding: 0;
        }
        #exportString {
            width: 100%;
            min-height: 60px;
            resize: vertical;
        }
        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #modalContent {
            background: white;
            border-radius: 8px;
            padding: 20px;
            position: relative;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
        }
        #modalClose {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc2626;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
        }
        #previewCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.3;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4 font-sans">
    <div class="bg-white rounded-lg shadow-lg p-6 max-w-3xl w-full">
        <h1 class="text-2xl font-bold text-gray-800 mb-4 text-center">Pixel Animator</h1>
        <div class="mb-6 border border-gray-200 rounded-md p-4 bg-gray-50">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">
                Projectbeheer: <span id="currentProjectName" class="text-blue-600">Geen project geselecteerd</span>
            </h2>
            <div class="flex gap-2 mb-3">
                <input type="text" id="newProjectName" placeholder="Projectnaam" maxlength="30" class="border border-gray-300 rounded-md px-3 py-2 w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                <input type="file" id="imageUpload" accept="image/*" class="border border-gray-300 rounded-md px-3 py-2 text-gray-700">
                <input type="file" id="videoUpload" accept="video/webm" class="border border-gray-300 rounded-md px-3 py-2 text-gray-700">
                <button id="createProject" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Nieuw Project</button>
            </div>
            <div class="flex gap-2 mb-3">
                <button id="exportProject" class="bg-teal-600 text-white px-4 py-2 rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 transition">Exporteer Project</button>
                <input type="text" id="importString" placeholder="Plak projectstring" class="border border-gray-300 rounded-md px-3 py-2 w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="importProject" class="bg-teal-600 text-white px-4 py-2 rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 transition">Importeer Project</button>
            </div>
            <textarea id="exportString" readonly class="border border-gray-300 rounded-md px-3 py-2 text-gray-700 mb-3" placeholder="Projectstring verschijnt hier na export"></textarea>
            <div id="canvasInfo" class="text-sm text-gray-600 mb-2"></div>
            <div id="projectList" class="border border-gray-200 rounded-md p-2 bg-white">
                <p id="noProjects" class="text-gray-500 text-sm text-center">Geen projecten beschikbaar</p>
            </div>
        </div>
        <div id="canvasWrapper" class="relative mx-auto mb-6 border border-gray-300 rounded-md overflow-hidden bg-white">
            <canvas id="mainCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
            <canvas id="overlayCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
            <canvas id="previewCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
            <canvas id="guidesCanvas" width="100" height="100" class="absolute top-0 left-0"></canvas>
        </div>
        <div class="grid grid-cols-1 gap-4">
            <div class="flex justify-center items-center gap-3 flex-wrap">
                <input type="color" id="colorPicker" value="#000000" class="w-10 h-10 rounded-md cursor-pointer border border-gray-300">
                <button id="drawMode" class="toggle-btn bg-gray-200 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition active">Tekenen</button>
                <button id="eraseMode" class="toggle-btn bg-gray-200 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Gommen</button>
                <button id="pickMode" class="toggle-btn bg-gray-200 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Kleurkiezer</button>
                <select id="mirrorMode" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="none">Geen spiegeling</option>
                    <option value="horizontal">Horizontaal (X-as)</option>
                    <option value="vertical">Verticaal (Y-as)</option>
                    <option value="both">Beide (X+Y-as)</option>
                </select>
                <label class="flex items-center gap-2 text-gray-700">
                    <input type="checkbox" id="overlayToggle" checked class="h-5 w-5 rounded focus:ring-blue-500">
                    Overlay
                </label>
                <label class="flex items-center gap-2 text-gray-700">
                    <input type="checkbox" id="crosshairToggle" checked class="h-5 w-5 rounded focus:ring-blue-500">
                    Kruislijnen
                </label>
                <select id="brushSize" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="1">1x1</option>
                    <option value="3">3x3</option>
                    <option value="5">5x5</option>
                    <option value="7">7x7</option>
                </select>
            </div>
            <div class="flex justify-center gap-2 flex-wrap">
                <input type="text" id="colorName" placeholder="Kleurnaam" maxlength="20" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="saveColor" class="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 transition">Kleur Opslaan</button>
            </div>
            <div id="colorList" class="border border-gray-200 rounded-md p-2 bg-white"></div>
            <div class="flex justify-center gap-2 flex-wrap">
                <button id="playAnimation" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition">Speel Animatie</button>
                <button id="newFrame" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">Nieuw Frame</button>
                <button id="prevFrame" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition">Vorige</button>
                <button id="nextFrame" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition">Volgende</button>
                <button id="deleteFrame" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 transition">Verwijder Frame</button>
                <button id="deleteAllFrames" class="bg-red-800 text-white px-4 py-2 rounded-md hover:bg-red-900 focus:outline-none focus:ring-2 focus:ring-red-500 transition">Verwijder Alles</button>
                <button id="exportVideo" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition">Exporteer Video</button>
            </div>
            <div id="frameInfo" class="text-center text-lg font-semibold text-gray-800">Geen project geselecteerd</div>
        </div>
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const guidesCanvas = document.getElementById('guidesCanvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
        const overlayCtx = overlayCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');
        const guidesCtx = guidesCanvas.getContext('2d');
        mainCtx.imageSmoothingEnabled = false;
        overlayCtx.imageSmoothingEnabled = false;
        previewCtx.imageSmoothingEnabled = false;
        guidesCtx.imageSmoothingEnabled = false;
        const colorPicker = document.getElementById('colorPicker');
        const drawModeBtn = document.getElementById('drawMode');
        const eraseModeBtn = document.getElementById('eraseMode');
        const pickModeBtn = document.getElementById('pickMode');
        const mirrorModeSelect = document.getElementById('mirrorMode');
        const overlayToggle = document.getElementById('overlayToggle');
        const crosshairToggle = document.getElementById('crosshairToggle');
        const brushSizeSelect = document.getElementById('brushSize');
        const newFrameBtn = document.getElementById('newFrame');
        const prevFrameBtn = document.getElementById('prevFrame');
        const nextFrameBtn = document.getElementById('nextFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const deleteAllFramesBtn = document.getElementById('deleteAllFrames');
        const exportVideoBtn = document.getElementById('exportVideo');
        const playAnimationBtn = document.getElementById('playAnimation');
        const frameInfo = document.getElementById('frameInfo');
        const newProjectName = document.getElementById('newProjectName');
        const imageUpload = document.getElementById('imageUpload');
        const videoUpload = document.getElementById('videoUpload');
        const createProjectBtn = document.getElementById('createProject');
        const exportProjectBtn = document.getElementById('exportProject');
        const importStringInput = document.getElementById('importString');
        const importProjectBtn = document.getElementById('importProject');
        const exportStringTextarea = document.getElementById('exportString');
        const projectList = document.getElementById('projectList');
        const noProjects = document.getElementById('noProjects');
        const currentProjectName = document.getElementById('currentProjectName');
        const canvasInfo = document.getElementById('canvasInfo');
        const colorNameInput = document.getElementById('colorName');
        const saveColorBtn = document.getElementById('saveColor');
        const colorList = document.getElementById('colorList');

        let projects = {};
        let currentProject = null;
        let frames = [];
        let currentFrame = 0;
        let isDrawing = false;
        let mode = 'drawing';
        let canvasWidth = 100;
        let canvasHeight = 100;
        let brushSize = 1;

        let db;
        const dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open('pixelAnimatorDB', 1);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                db = request.result;
                resolve(db);
            };
            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains('projects')) {
                    db.createObjectStore('projects', { keyPath: 'name' });
                }
            };
        });

        async function loadProjects() {
            const db = await dbPromise;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['projects'], 'readonly');
                const store = transaction.objectStore('projects');
                const request = store.getAll();
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    const projectsObj = {};
                    request.result.forEach((p) => {
                        projectsObj[p.name] = {
                            frames: p.frames,
                            currentFrame: p.currentFrame,
                            width: p.width,
                            height: p.height,
                            colors: p.colors || []
                        };
                    });
                    resolve(projectsObj);
                };
            });
        }

        async function saveProject(projectName, data) {
            const db = await dbPromise;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                const fullData = {
                    name: projectName,
                    ...data
                };
                const request = store.put(fullData);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve();
            });
        }

        async function deleteProject(projectName) {
            const db = await dbPromise;
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                const request = store.delete(projectName);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve();
            });
        }

        async function saveCurrentProject() {
            if (!currentProject) return;
            const data = {
                frames: frames.map(frame => Array.from(frame.data)),
                currentFrame,
                width: canvasWidth,
                height: canvasHeight,
                colors: projects[currentProject]?.colors || []
            };
            projects[currentProject] = data;
            saveProject(currentProject, data).catch(console.error);
        }

        // Teken grid en kruislijnen
        function drawGuides(ctx) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvasWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
                ctx.stroke();
            }
            for (let y = 0; y <= canvasHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.stroke();
            }
            if (crosshairToggle.checked) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                const cx = canvasWidth / 2;
                const cy = canvasHeight / 2;
                ctx.beginPath();
                ctx.moveTo(cx, 0);
                ctx.lineTo(cx, canvasHeight);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, cy);
                ctx.lineTo(canvasWidth, cy);
                ctx.stroke();
            }
        }

        // Update canvas en overlay
        function updateCanvas(clearPreview = true) {
            if (!currentProject) {
                mainCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                frameInfo.textContent = 'Geen project geselecteerd';
                currentProjectName.textContent = 'Geen project geselecteerd';
                canvasInfo.textContent = '';
                colorList.innerHTML = '';
                exportStringTextarea.value = '';
                disableControls(true);
                drawGuides(guidesCtx);
                return;
            }
            disableControls(false);
            mainCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            mainCtx.putImageData(frames[currentFrame], 0, 0);
            overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            if (overlayToggle.checked && currentFrame > 0) {
                overlayCtx.putImageData(frames[currentFrame - 1], 0, 0);
            }
            if (clearPreview) {
                previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            }
            frameInfo.textContent = `Frame ${currentFrame + 1} / ${frames.length}`;
            currentProjectName.textContent = currentProject;
            canvasInfo.textContent = `Canvas: ${canvasWidth}x${canvasHeight} pixels`;
            updateColorList();
            exportStringTextarea.value = '';
            deleteFrameBtn.disabled = frames.length <= 1;
            deleteAllFramesBtn.disabled = frames.length <= 1;
            saveCurrentProject();
            drawGuides(guidesCtx);
        }

        // Schakel controls in/uit
        function disableControls(disabled) {
            [newFrameBtn, prevFrameBtn, nextFrameBtn, deleteFrameBtn, deleteAllFramesBtn, exportVideoBtn, playAnimationBtn, exportProjectBtn, importProjectBtn, colorPicker, drawModeBtn, eraseModeBtn, pickModeBtn, overlayToggle, mirrorModeSelect, crosshairToggle, saveColorBtn, colorNameInput, brushSizeSelect].forEach(el => {
                el.disabled = disabled;
                el.classList.toggle('opacity-50', disabled);
                el.classList.toggle('cursor-not-allowed', disabled);
            });
        }

        // Haal pixels voor brush
        function getBrushPixels(centerX, centerY) {
            const half = Math.floor(brushSize / 2);
            const pixels = [];
            for (let dx = -half; dx <= half; dx++) {
                for (let dy = -half; dy <= half; dy++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight) {
                        pixels.push({ x, y });
                    }
                }
            }
            return pixels;
        }

        // Pas mirror toe op lijst van pixels
        function applyMirror(pixels) {
            const mirrorMode = mirrorModeSelect.value;
            const mirroredPixels = [...pixels];
            pixels.forEach(({ x, y }) => {
                if (mirrorMode === 'horizontal' || mirrorMode === 'both') {
                    const mx = canvasWidth - x - 1;
                    if (mx !== x || mirrorMode === 'both') mirroredPixels.push({ x: mx, y });
                }
                if (mirrorMode === 'vertical' || mirrorMode === 'both') {
                    const my = canvasHeight - y - 1;
                    if (my !== y || mirrorMode === 'both') mirroredPixels.push({ x, y: my });
                }
                if (mirrorMode === 'both') {
                    const mx = canvasWidth - x - 1;
                    const my = canvasHeight - y - 1;
                    if (mx !== x || my !== y) mirroredPixels.push({ x: mx, y: my });
                }
            });
            // Verwijder duplicaten
            return [...new Set(mirroredPixels.map(p => `${p.x},${p.y}`))].map(str => {
                const [x, y] = str.split(',').map(Number);
                return { x, y };
            });
        }

        // Teken preview
        function drawPreview(x, y) {
            if (!currentProject || mode === 'picking') return;
            previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            const centerX = Math.floor(x);
            const centerY = Math.floor(y);
            if (centerX < 0 || centerX >= canvasWidth || centerY < 0 || centerY >= canvasHeight) return;

            let brushPixels = getBrushPixels(centerX, centerY);
            brushPixels = applyMirror(brushPixels);

            const color = mode === 'erasing' ? 'rgba(255,255,255,1)' : colorPicker.value;
            previewCtx.fillStyle = color;
            brushPixels.forEach(({ x, y }) => {
                previewCtx.fillRect(x, y, 1, 1);
            });
        }

        // Teken, wis of kies kleur
        function modifyPixels(centerX, centerY) {
            if (!currentProject) return;
            const centerXFloor = Math.floor(centerX);
            const centerYFloor = Math.floor(centerY);
            if (centerXFloor < 0 || centerXFloor >= canvasWidth || centerYFloor < 0 || centerYFloor >= canvasHeight) return;

            if (mode === 'picking') {
                const pixel = mainCtx.getImageData(centerXFloor, centerYFloor, 1, 1).data;
                if (pixel[3] !== 0) {
                    colorPicker.value = rgbToHex(pixel[0], pixel[1], pixel[2]);
                }
                return;
            }

            let brushPixels = getBrushPixels(centerXFloor, centerYFloor);
            brushPixels = applyMirror(brushPixels);

            const frameData = frames[currentFrame].data;
            brushPixels.forEach(({ x, y }) => {
                const index = (y * canvasWidth + x) * 4;
                if (mode === 'drawing') {
                    const { r, g, b } = hexToRgb(colorPicker.value);
                    frameData[index] = r;
                    frameData[index + 1] = g;
                    frameData[index + 2] = b;
                    frameData[index + 3] = 255;
                } else if (mode === 'erasing') {
                    frameData[index] = frameData[index + 1] = frameData[index + 2] = frameData[index + 3] = 0;
                }
            });
            mainCtx.putImageData(frames[currentFrame], 0, 0);
            updateCanvas(false); // Update overlay and guides, but not clear preview
        }

        // Converteer RGB naar hex
        function rgbToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0')}`;
        }

        // Converteer hex naar RGB
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return { r, g, b };
        }

        // Kleurenbeheer
        function updateColorList() {
            colorList.innerHTML = '';
            if (currentProject && projects[currentProject].colors) {
                projects[currentProject].colors.forEach((color, index) => {
                    const card = document.createElement('div');
                    card.className = 'color-card';
                    card.style.backgroundColor = color.hex;
                    card.innerHTML = `<span>${color.name}</span><button>X</button>`;
                    card.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'BUTTON') {
                            colorPicker.value = color.hex;
                        }
                    });
                    card.querySelector('button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        projects[currentProject].colors.splice(index, 1);
                        saveCurrentProject();
                        updateColorList();
                    });
                    colorList.appendChild(card);
                });
            }
        }

        saveColorBtn.addEventListener('click', () => {
            if (!currentProject) return;
            const name = colorNameInput.value.trim().replace(/[^a-zA-Z0-9-_ ]/g, '');
            const hex = colorPicker.value;
            if (name && !projects[currentProject].colors?.some(c => c.hex === hex)) {
                projects[currentProject].colors = projects[currentProject].colors || [];
                projects[currentProject].colors.push({ name, hex });
                saveCurrentProject();
                updateColorList();
                colorNameInput.value = '';
            }
        });

        // Projectbeheer
        function loadProject(name) {
            currentProject = name;
            const project = projects[name];
            canvasWidth = project.width;
            canvasHeight = project.height;
            [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
            });
            canvasWrapper.style.width = `${canvasWidth * 6}px`;
            canvasWrapper.style.height = `${canvasHeight * 6}px`;
            [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                canvas.style.width = `${canvasWidth * 6}px`;
                canvas.style.height = `${canvasHeight * 6}px`;
            });
            frames = project.frames.map(data => {
                const imgData = mainCtx.createImageData(canvasWidth, canvasHeight);
                imgData.data.set(new Uint8ClampedArray(data));
                return imgData;
            });
            currentFrame = Math.min(project.currentFrame || 0, frames.length - 1);
            updateCanvas();
            updateProjectList();
        }

        function updateProjectList() {
            projectList.innerHTML = '';
            if (!Object.keys(projects).length) {
                noProjects.style.display = 'block';
                return;
            }
            noProjects.style.display = 'none';
            Object.keys(projects).sort().forEach(name => {
                const div = document.createElement('div');
                div.className = `flex justify-between items-center p-2 rounded-md cursor-pointer project-item ${currentProject === name ? 'selected' : ''}`;
                div.innerHTML = `<span>${name}</span><button class="text-red-600 hover:text-red-800 text-sm">Verwijder</button>`;
                div.querySelector('button').addEventListener('click', async (e) => {
                    e.stopPropagation();
                    if (confirm(`Weet je zeker dat je project "${name}" wilt verwijderen?`)) {
                        delete projects[name];
                        await deleteProject(name);
                        if (currentProject === name) {
                            currentProject = null;
                            frames = [];
                            currentFrame = 0;
                            canvasWidth = canvasHeight = 100;
                            [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                                canvas.width = canvasWidth;
                                canvas.height = canvasHeight;
                                canvas.style.width = `${canvasWidth * 6}px`;
                                canvas.style.height = `${canvasHeight * 6}px`;
                            });
                            canvasWrapper.style.width = `${canvasWidth * 6}px`;
                            canvasWrapper.style.height = `${canvasHeight * 6}px`;
                            updateCanvas();
                        }
                        updateProjectList();
                    }
                });
                div.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'BUTTON' && currentProject !== name) loadProject(name);
                });
                projectList.appendChild(div);
            });
        }

        // Afbeelding uploaden
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const img = new Image();
            img.onload = () => {
                canvasWidth = img.width;
                canvasHeight = img.height;
                [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                });
                canvasWrapper.style.width = `${canvasWidth * 6}px`;
                canvasWrapper.style.height = `${canvasHeight * 6}px`;
                [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                    canvas.style.width = `${canvasWidth * 6}px`;
                    canvas.style.height = `${canvasHeight * 6}px`;
                });
                mainCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                frames = [mainCtx.getImageData(0, 0, canvasWidth, canvasHeight)];
                currentFrame = 0;
                if (currentProject) saveCurrentProject();
                updateCanvas();
                e.target.value = '';
            };
            img.onerror = () => {
                alert('Fout bij laden van afbeelding.');
                e.target.value = '';
            };
            img.src = URL.createObjectURL(file);
        });

        // Video uploaden
        videoUpload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (!file.type.includes('webm')) {
                alert('Alleen WebM bestanden ondersteund.');
                return;
            }
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.muted = true;
            try {
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                    video.oncanplay = resolve;
                });
                const w = video.videoWidth;
                const h = video.videoHeight;
                if (w === 0 || h === 0) {
                    alert('Ongeldige video dimensies.');
                    return;
                }
                canvasWidth = w;
                canvasHeight = h;
                [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                    canvas.width = w;
                    canvas.height = h;
                });
                canvasWrapper.style.width = `${w * 6}px`;
                canvasWrapper.style.height = `${h * 6}px`;
                [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                    canvas.style.width = `${w * 6}px`;
                    canvas.style.height = `${h * 6}px`;
                });
                const fps = 10; // Lagere FPS voor betere performance
                const totalFrames = Math.floor(video.duration * fps) + 1;
                video.currentTime = 0;
                video.play();
                const extractedFrames = [];
                for (let i = 0; i < totalFrames; i++) {
                    await new Promise(resolve => {
                        const checkSeeked = () => {
                            if (Math.abs(video.currentTime - i / fps) < 0.1) {
                                resolve();
                            } else {
                                requestAnimationFrame(checkSeeked);
                            }
                        };
                        video.currentTime = i / fps;
                        checkSeeked();
                    });
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(video, 0, 0, w, h);
                    const imgData = tempCtx.getImageData(0, 0, w, h);
                    extractedFrames.push(imgData);
                }
                video.pause();
                URL.revokeObjectURL(video.src);
                frames = extractedFrames;
                currentFrame = 0;
                let name = 'WebM Import';
                let baseName = name;
                let counter = 1;
                while (projects[name]) {
                    name = `${baseName} ${counter++}`;
                }
                const data = {
                    frames: frames.map(f => Array.from(f.data)),
                    currentFrame: 0,
                    width: w,
                    height: h,
                    colors: []
                };
                projects[name] = data;
                await saveProject(name, data);
                currentProject = name;
                updateCanvas();
                updateProjectList();
            } catch (error) {
                console.error('Fout bij video upload:', error);
                alert('Fout bij het laden van de video. Probeer een kortere video.');
            }
            e.target.value = '';
        });

        // Project exporteren/importeren
        exportProjectBtn.addEventListener('click', () => {
            if (!currentProject) return;
            const projectData = {
                name: currentProject,
                frames: frames.map(frame => Array.from(frame.data)),
                currentFrame,
                width: canvasWidth,
                height: canvasHeight,
                colors: projects[currentProject].colors || []
            };
            exportStringTextarea.value = LZString.compressToBase64(JSON.stringify(projectData));
            exportStringTextarea.select();
            document.execCommand('copy');
            alert('Projectstring gekopieerd naar klembord!');
        });

        importProjectBtn.addEventListener('click', async () => {
            const str = importStringInput.value.trim();
            if (!str) return;
            try {
                const decompressed = LZString.decompressFromBase64(str);
                if (!decompressed) throw new Error('Decompressie mislukt');
                const projectData = JSON.parse(decompressed);
                let name = projectData.name.replace(/[^a-zA-Z0-9-_]/g, '').substring(0, 30) || 'ImportedProject';
                let baseName = name;
                let counter = 1;
                while (projects[name]) name = `${baseName}_${counter++}`;
                const data = {
                    frames: projectData.frames,
                    currentFrame: Math.min(projectData.currentFrame || 0, projectData.frames.length - 1),
                    width: projectData.width,
                    height: projectData.height,
                    colors: projectData.colors || []
                };
                projects[name] = data;
                await saveProject(name, data);
                loadProject(name);
                importStringInput.value = '';
                updateProjectList();
            } catch (e) {
                console.error(e);
                alert('Ongeldige projectstring. Controleer of de string correct is.');
            }
        });

        createProjectBtn.addEventListener('click', async () => {
            const name = newProjectName.value.trim().replace(/[^a-zA-Z0-9-_]/g, '').substring(0, 30);
            if (!name) {
                alert('Voer een geldige projectnaam in.');
                return;
            }
            if (projects[name]) {
                alert('Projectnaam bestaat al.');
                return;
            }
            const emptyData = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);
            const data = {
                frames: [Array.from(emptyData)],
                currentFrame: 0,
                width: canvasWidth,
                height: canvasHeight,
                colors: []
            };
            projects[name] = data;
            try {
                await saveProject(name, data);
                loadProject(name);
                newProjectName.value = '';
                updateProjectList();
            } catch (e) {
                console.error(e);
                delete projects[name];
                alert('Fout bij opslaan project.');
                updateProjectList();
            }
        });

        // Modus schakelen
        [drawModeBtn, eraseModeBtn, pickModeBtn].forEach(btn => {
            btn.addEventListener('click', () => {
                [drawModeBtn, eraseModeBtn, pickModeBtn].forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (btn === drawModeBtn) mode = 'drawing';
                else if (btn === eraseModeBtn) mode = 'erasing';
                else if (btn === pickModeBtn) mode = 'picking';
            });
        });

        brushSizeSelect.addEventListener('change', () => {
            brushSize = parseInt(brushSizeSelect.value);
        });

        colorPicker.addEventListener('change', () => {
            previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        });

        // Muis events op canvasWrapper voor betere compatibiliteit
        canvasWrapper.addEventListener('mousedown', (e) => {
            if (!currentProject) return;
            isDrawing = true;
            const rect = canvasWrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvasWidth / rect.width);
            const y = (e.clientY - rect.top) * (canvasHeight / rect.height);
            modifyPixels(x, y);
        });

        canvasWrapper.addEventListener('mousemove', (e) => {
            if (!currentProject) return;
            const rect = canvasWrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvasWidth / rect.width);
            const y = (e.clientY - rect.top) * (canvasHeight / rect.height);
            if (isDrawing) {
                modifyPixels(x, y);
            } else {
                drawPreview(x, y);
            }
        });

        canvasWrapper.addEventListener('mouseup', () => {
            isDrawing = false;
            if (currentProject) updateCanvas();
        });

        canvasWrapper.addEventListener('mouseleave', () => {
            isDrawing = false;
            if (currentProject) previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        });

        // Touch events voor mobiel
        let touchId = null;
        canvasWrapper.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!currentProject || e.touches.length !== 1) return;
            const touch = e.touches[0];
            touchId = touch.identifier;
            isDrawing = true;
            const rect = canvasWrapper.getBoundingClientRect();
            const x = (touch.clientX - rect.left) * (canvasWidth / rect.width);
            const y = (touch.clientY - rect.top) * (canvasHeight / rect.height);
            modifyPixels(x, y);
        });

        canvasWrapper.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!currentProject || !isDrawing) return;
            const touch = Array.from(e.touches).find(t => t.identifier === touchId);
            if (!touch) return;
            const rect = canvasWrapper.getBoundingClientRect();
            const x = (touch.clientX - rect.left) * (canvasWidth / rect.width);
            const y = (touch.clientY - rect.top) * (canvasHeight / rect.height);
            modifyPixels(x, y);
        });

        canvasWrapper.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
            if (currentProject) updateCanvas();
            touchId = null;
        });

        // Frame controls
        newFrameBtn.addEventListener('click', () => {
            if (!currentProject) return;
            const newFrame = mainCtx.createImageData(canvasWidth, canvasHeight);
            newFrame.data.set(frames[currentFrame].data);
            frames.splice(currentFrame + 1, 0, newFrame);
            currentFrame++;
            updateCanvas();
        });

        prevFrameBtn.addEventListener('click', () => {
            if (currentFrame > 0) {
                currentFrame--;
                updateCanvas();
            }
        });

        nextFrameBtn.addEventListener('click', () => {
            if (currentFrame < frames.length - 1) {
                currentFrame++;
                updateCanvas();
            }
        });

        deleteFrameBtn.addEventListener('click', () => {
            if (frames.length > 1 && confirm('Weet je zeker dat je dit frame wilt verwijderen?')) {
                frames.splice(currentFrame, 1);
                if (currentFrame >= frames.length) currentFrame = frames.length - 1;
                updateCanvas();
            }
        });

        deleteAllFramesBtn.addEventListener('click', () => {
            if (confirm('Weet je zeker dat je alle frames wilt verwijderen?')) {
                const emptyData = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);
                frames = [mainCtx.createImageData(canvasWidth, canvasHeight)];
                frames[0].data.set(emptyData);
                currentFrame = 0;
                updateCanvas();
            }
        });

        overlayToggle.addEventListener('change', () => updateCanvas());
        crosshairToggle.addEventListener('change', () => updateCanvas());
        mirrorModeSelect.addEventListener('change', () => {
            updateCanvas();
            previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        });

        // Video-opname
        async function recordVideo(callback) {
            if (!currentProject || !frames.length) return;
            const videoCanvas = document.createElement('canvas');
            videoCanvas.width = canvasWidth;
            videoCanvas.height = canvasHeight;
            const videoCtx = videoCanvas.getContext('2d');
            videoCtx.imageSmoothingEnabled = false;
            const stream = videoCanvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
            const chunks = [];

            recorder.ondataavailable = (e) => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                callback(blob);
            };

            recorder.start();
            let frameIndex = 0;
            const frameDuration = 1000 / 30;

            function renderLoop(timestamp) {
                if (frameIndex >= frames.length) {
                    recorder.stop();
                    return;
                }
                videoCtx.putImageData(frames[frameIndex], 0, 0);
                frameIndex++;
                setTimeout(() => requestAnimationFrame(renderLoop), frameDuration);
            }
            requestAnimationFrame(renderLoop);
        }

        // Speel animatie
        playAnimationBtn.addEventListener('click', () => {
            if (!currentProject) return;
            recordVideo((blob) => {
                const url = URL.createObjectURL(blob);
                const modal = document.createElement('div');
                modal.id = 'modal';
                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1000;';
                modal.innerHTML = `
                    <div id="modalContent" style="background:white;border-radius:8px;padding:20px;position:relative;max-width:90%;max-height:90%;overflow:auto;">
                        <button id="modalClose" style="position:absolute;top:10px;right:10px;background:#dc2626;color:white;border-radius:50%;width:30px;height:30px;display:flex;align-items:center;justify-content:center;font-size:16px;cursor:pointer;border:none;">X</button>
                        <video controls autoplay loop style="width:${canvasWidth * 6}px;height:${canvasHeight * 6}px;image-rendering:pixelated;"></video>
                    </div>
                `;
                document.body.appendChild(modal);
                const video = modal.querySelector('video');
                video.src = url;
                modal.querySelector('#modalClose').addEventListener('click', () => {
                    modal.remove();
                    URL.revokeObjectURL(url);
                });
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                        URL.revokeObjectURL(url);
                    }
                });
            });
        });

        // Exporteer video
        exportVideoBtn.addEventListener('click', () => {
            if (!currentProject) return;
            recordVideo((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentProject || 'animation'}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        });

        // Initiële setup
        (async () => {
            try {
                await dbPromise;
                projects = await loadProjects();
                updateProjectList();
                if (Object.keys(projects).length) {
                    loadProject(Object.keys(projects)[0]);
                } else {
                    canvasWidth = canvasHeight = 100;
                    [mainCanvas, overlayCanvas, previewCanvas, guidesCanvas].forEach(canvas => {
                        canvas.width = canvasWidth;
                        canvas.height = canvasHeight;
                        canvas.style.width = `${canvasWidth * 6}px`;
                        canvas.style.height = `${canvasHeight * 6}px`;
                    });
                    canvasWrapper.style.width = `${canvasWidth * 6}px`;
                    canvasWrapper.style.height = `${canvasHeight * 6}px`;
                    const emptyData = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);
                    frames = [mainCtx.createImageData(canvasWidth, canvasHeight)];
                    frames[0].data.set(emptyData);
                    updateCanvas();
                }
            } catch (e) {
                console.error('Failed to load DB', e);
                projects = {};
                updateProjectList();
                updateCanvas();
            }
        })();
    </script>
</body>
</html>
