<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Game Engine - Debug Overlay</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; color: #0f0; font-family: monospace; word-wrap: break-word; overflow-wrap: break-word; }
  canvas { background: #222; display: block; margin: 0 auto; }
  #debug {
    position: absolute; top: 10px; right: 10px;
    background: rgba(0,0,0,0.7); padding: 10px;
    border: 1px solid #0f0; max-width: 300px; font-size: 14px; word-wrap: break-word; overflow-wrap: break-word; white-space: pre-wrap;
  }
  #toggle {
    position: absolute; left: 10px; top: 10px; z-index: 10; background: rgba(0,0,0,0.7); color: #0f0; border: 1px solid #0f0; padding: 5px; font-family: monospace;
  }
  #sidebar {
    position: absolute; left: 0; top: 0; width: 250px; height: 100%; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px; border-right: 1px solid #0f0; font-family: monospace; font-size: 12px;
    transform: translateX(-100%); transition: transform 0.3s ease;
    overflow-y: auto; word-wrap: break-word; overflow-wrap: break-word;
  }
  #sidebar.open { transform: translateX(0); }
  #sidebar label { display: block; margin: 10px 0; }
  #sidebar input[type="number"] { width: 100px; background: #222; color: #0f0; border: 1px solid #0f0; padding: 2px; }
  #sidebar input[type="checkbox"] { margin-left: 10px; }
  #sidebar h3 { margin-top: 0; }
</style>
</head>
<body>
<canvas id="game" width="900" height="600"></canvas>
<button id="toggle">Toggle Sidebar</button>
<div id="sidebar">
  <h3>Settings</h3>
  <label>Gravity: <input type="number" id="gravity" min="100" max="2000" value="900" step="10"> <span id="gval">900</span></label>
  <label>Player Speed: <input type="number" id="speed" min="50" max="1000000" value="200" step="10"> <span id="sval">200</span></label>
  <label>Jump Height: <input type="number" id="jump" min="100" max="800" value="400" step="10"> <span id="jval">400</span></label>
  <label>Debug: <input type="checkbox" id="debugToggle" checked> <span id="dtval">true</span></label>
  <label>Platforms (stacked): <input type="number" id="platforms" min="0" max="100000" value="10000" step="1"> <span id="pval">10000</span></label>
  <!-- Add more settings here as needed -->
</div>
<div id="debug"></div>
<script>
// ======== VECTOR CLASS (Immutable operations) ========
class Vec2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
  sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
  scale(s) { return new Vec2(this.x * s, this.y * s); }
  dot(v) { return this.x * v.x + this.y * v.y; }
  perp() { return new Vec2(-this.y, this.x); }
  len() { return Math.hypot(this.x, this.y); }
  norm() {
    const l = this.len();
    return l ? this.scale(1 / l) : new Vec2();
  }
  clone() { return new Vec2(this.x, this.y); }
}

// ======== AABB OVERLAP HELPER ========
function aabbOverlap(a, b) {
  return a.maxX >= b.minX && a.minX <= b.maxX &&
         a.maxY >= b.minY && a.minY <= b.maxY;
}

// ======== POLYGON AND SAT COLLISION DETECTION ========
class Polygon {
  constructor(points) {
    this.points = points.map(p => new Vec2(p.x, p.y)); // Ensure Vec2
    this.axes = this.getAxes();
  }
  getAxes() {
    const axes = [];
    for (let i = 0; i < this.points.length; i++) {
      const p1 = this.points[i];
      const p2 = this.points[(i + 1) % this.points.length];
      const edge = p2.sub(p1);
      const axis = edge.perp().norm();
      if (axis.len() > 0) { // Avoid zero-length edges
        axes.push(axis);
      }
    }
    return axes;
  }
  getAABB(pos) {
    const pts = this.getTransformed(pos);
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of pts) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    return { minX, minY, maxX, maxY };
  }
  getTransformed(pos) {
    return this.points.map(p => p.add(pos));
  }
  project(axis, pos) {
    const pts = this.getTransformed(pos);
    let min = pts[0].dot(axis);
    let max = min;
    for (let i = 1; i < pts.length; i++) {
      const proj = pts[i].dot(axis);
      if (proj < min) min = proj;
      if (proj > max) max = proj;
    }
    return { min, max };
  }
  static overlap(A, posA, B, posB) {
    const axes = [...A.axes, ...B.axes];
    let overlap = Infinity;
    let smallestAxis = null;
    for (const axis of axes) {
      if (axis.len() === 0) continue; // Skip invalid axes
      const projA = A.project(axis, posA);
      const projB = B.project(axis, posB);
      const o = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
      if (o < 0) return null;
      if (o < overlap) {
        overlap = o;
        smallestAxis = axis;
      }
    }
    if (smallestAxis === null) return null;
    const d = posA.sub(posB);
    if (d.dot(smallestAxis) < 0) {
      smallestAxis = smallestAxis.scale(-1);
    }
    return { axis: smallestAxis, overlap };
  }
}

// ======== ENTITY CLASS (Physics and Movement) ========
class Entity {
  constructor(x, y, shape) {
    this.pos = new Vec2(x, y);
    this.vel = new Vec2(0, 0);
    this.shape = shape;
    this.color = "#4af";
    this.static = false;
    this.aabb = this.static ? this.shape.getAABB(this.pos) : null;
    this.onGround = false;
    this.groundNormal = new Vec2(0, -1);
    this.groundAngle = 0;
    this.isTestPlatform = false;
  }
  update(dt, world) {
    if (this.static) return;

    const oldOnGround = this.onGround;
    this.onGround = false;

    const input_speed = world.keys["ArrowLeft"]
      ? -world.playerSpeed
      : world.keys["ArrowRight"]
      ? world.playerSpeed
      : 0;
    const horiz = new Vec2(input_speed, 0);
    const g_vec = new Vec2(0, world.gravity * dt);

    // Apply input using old ground info
    if (oldOnGround) {
      const tangent = this.groundNormal.perp().norm();
      const vt = horiz.dot(tangent);
      const vn = this.vel.dot(this.groundNormal);
      this.vel = tangent.scale(vt).add(this.groundNormal.scale(vn));
    } else {
      this.vel.x = horiz.x;
    }

    // Add gravity
    this.vel = this.vel.add(g_vec);

    // Substep position update to prevent tunneling
    const disp = this.vel.scale(dt);
    const maxSubLen = 5;
    let numSteps = Math.max(1, Math.ceil(disp.len() / maxSubLen));
    const subDisp = disp.scale(1 / numSteps);
    let currentPos = this.pos.clone();
    const up = new Vec2(0, -1);
    const maxIter = 10;
    for (let step = 0; step < numSteps; step++) {
      let testPos = currentPos.add(subDisp);
      let iterations = 0;
      let hasCollision = false;
      while (iterations < maxIter) {
        hasCollision = false;
        const testAABB = this.shape.getAABB(testPos);
        for (const other of world.getNearby(testPos)) {
          if (!other.shape || other === this) continue;
          const otherAABB = other.aabb || other.shape.getAABB(other.pos);
          if (!aabbOverlap(testAABB, otherAABB)) continue;
          const res = Polygon.overlap(this.shape, testPos, other.shape, other.pos);
          if (res) {
            hasCollision = true;
            testPos = testPos.add(res.axis.scale(res.overlap));
            const vn = this.vel.dot(res.axis);
            if (vn < 0) {
              this.vel = this.vel.sub(res.axis.scale(vn));
            }
            if (res.axis.dot(up) > 0.01) {
              this.onGround = true;
              this.groundNormal = res.axis;
            }
          }
        }
        if (!hasCollision) break;
        iterations++;
      }
      currentPos = testPos;
    }
    this.pos = currentPos;

    // Post-collision adjustments
    if (this.onGround) {
      // Remove normal velocity component
      const vn = this.vel.dot(this.groundNormal);
      this.vel = this.vel.sub(this.groundNormal.scale(vn));

      // Set desired tangential velocity
      const tangent = this.groundNormal.perp().norm();
      const desired_vt = horiz.dot(tangent);
      this.vel = tangent.scale(desired_vt);

      // Correct position for gravity tangential component to prevent sliding
      const g_tang_scalar = g_vec.dot(tangent);
      this.pos = this.pos.sub(tangent.scale(g_tang_scalar * dt));

      // Calculate ground angle
      const vertical = new Vec2(0, -1);
      const cosTheta = this.groundNormal.dot(vertical);
      this.groundAngle = Math.acos(Math.max(-1, Math.min(1, cosTheta))) * 180 / Math.PI;
    } else {
      // Air control: only horizontal
      this.vel.x = horiz.x;
    }

    // Jump logic (along normal)
    if (world.keys["Space"] && oldOnGround) {
      const upDir = this.groundNormal;
      const target_v = upDir.scale(world.jumpHeight);
      this.vel = this.vel.add(target_v);
      this.onGround = false;
    }
  }

  draw(ctx, debug = false, useTexture = false) {
    const pts = this.shape.getTransformed(this.pos);
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) {
      ctx.lineTo(pts[i].x, pts[i].y);
    }
    ctx.closePath();

    if (useTexture && texture.complete) {
      ctx.save();
      ctx.clip();
      const aabb = this.shape.getAABB(this.pos);
      ctx.drawImage(texture, aabb.minX, aabb.minY, aabb.maxX - aabb.minX, aabb.maxY - aabb.minY);
      ctx.restore();
    } else {
      ctx.fillStyle = this.color;
      ctx.fill();
    }

    if (debug && !this.isTestPlatform) {
      // Outline
      ctx.strokeStyle = "#f00";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.closePath();
      ctx.stroke();
      // Velocity arrow
      ctx.strokeStyle = "#0f0";
      ctx.beginPath();
      ctx.moveTo(this.pos.x, this.pos.y);
      ctx.lineTo(
        this.pos.x + this.vel.x * 0.1,
        this.pos.y + this.vel.y * 0.1
      );
      ctx.stroke();
    }
  }
}

// ======== WORLD CLASS (Manages entities and state) ========
class World {
  constructor(ctx) {
    this.ctx = ctx;
    this.entities = [];
    this.testPlatforms = [];
    this.gravity = 900;
    this.playerSpeed = 200;
    this.jumpHeight = 400;
    this.keys = {};
    this.cellSize = 200;
    this.spatialHash = new Map();
    this.player = null;
  }
  getHash(pos) {
    const hx = Math.floor(pos.x / this.cellSize);
    const hy = Math.floor(pos.y / this.cellSize);
    return `${hx},${hy}`;
  }
  rebuildSpatialHash() {
    this.spatialHash.clear();
    const posToEntity = new Map();
    for (const e of this.entities) {
      if (e.static && e.shape) {
        if (e.isTestPlatform) {
          // For test platforms, add only one representative per tolerance group
          const tolerance = 10;
          const gx = Math.floor(e.pos.x / tolerance);
          const gy = Math.floor(e.pos.y / tolerance);
          const posKey = `${gx},${gy}`;
          if (!posToEntity.has(posKey)) {
            posToEntity.set(posKey, e);
          }
          const rep = posToEntity.get(posKey);
          const hash = this.getHash(rep.pos);
          if (!this.spatialHash.has(hash)) {
            this.spatialHash.set(hash, []);
          }
          if (!this.spatialHash.get(hash).includes(rep)) {
            this.spatialHash.get(hash).push(rep);
          }
        } else {
          // For other statics, add all
          const hash = this.getHash(e.pos);
          if (!this.spatialHash.has(hash)) {
            this.spatialHash.set(hash, []);
          }
          if (!this.spatialHash.get(hash).includes(e)) {
            this.spatialHash.get(hash).push(e);
          }
        }
      }
    }
  }
  getNearby(pos) {
    const nearby = new Set();
    const cx = Math.floor(pos.x / this.cellSize);
    const cy = Math.floor(pos.y / this.cellSize);
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = -2; dy <= 2; dy++) {
        const h = `${cx + dx},${cy + dy}`;
        if (this.spatialHash.has(h)) {
          this.spatialHash.get(h).forEach(e => nearby.add(e));
        }
      }
    }
    return Array.from(nearby);
  }
  getVisible(viewMinX, viewMinY, viewMaxX, viewMaxY) {
    const visible = new Set();
    const cxMin = Math.floor(viewMinX / this.cellSize) - 1;
    const cxMax = Math.floor((viewMaxX - 1) / this.cellSize) + 1;
    const cyMin = Math.floor(viewMinY / this.cellSize) - 1;
    const cyMax = Math.floor((viewMaxY - 1) / this.cellSize) + 1;
    for (let cx = cxMin; cx <= cxMax; cx++) {
      for (let cy = cyMin; cy <= cyMax; cy++) {
        const h = `${cx},${cy}`;
        if (this.spatialHash.has(h)) {
          this.spatialHash.get(h).forEach(e => visible.add(e));
        }
      }
    }
    // Add non-static entities
    for (const e of this.entities) {
      if (!e.static) {
        visible.add(e);
      }
    }
    return Array.from(visible);
  }
  add(e) {
    this.entities.push(e);
  }
  update(dt) {
    for (const e of this.entities) {
      if (!e.static) e.update(dt, this);
    }
  }
  draw(debug = false, camX, camY) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const viewMinX = camX;
    const viewMaxX = camX + width;
    const viewMinY = camY;
    const viewMaxY = camY + height;
    const visible = this.getVisible(viewMinX, viewMinY, viewMaxX, viewMaxY);
    for (const e of visible) {
      const aabb = e.aabb || e.shape.getAABB(e.pos);
      if (aabb.maxX < viewMinX || aabb.minX > viewMaxX ||
          aabb.maxY < viewMinY || aabb.minY > viewMaxY) continue;
      const useTexture = true;
      e.draw(this.ctx, debug, useTexture);
    }
  }
}

// ======== HELPER: ROTATED RECTANGLE (Relative to center) ========
function RotatedRect(w, h, angleDeg) {
  const angle = angleDeg * Math.PI / 180;
  const hw = w / 2;
  const hh = h / 2;
  const corners = [
    new Vec2(-hw, -hh),
    new Vec2(hw, -hh),
    new Vec2(hw, hh),
    new Vec2(-hw, hh)
  ];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const rotated = corners.map(p =>
    new Vec2(
      p.x * cos - p.y * sin,
      p.x * sin + p.y * cos
    )
  );
  return new Polygon(rotated);
}

// ======== SETUP AND INITIALIZATION ========
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: true });
const debugDiv = document.getElementById("debug");
const world = new World(ctx);

const texture = new Image();
texture.src = 'https://placehold.co/200x200/555555/FFFFFF/png';

let showDebug = true;

// FPS counter
let frameCount = 0;
let lastFPSTime = 0;
let fps = 0;

// Input handling
window.addEventListener("keydown", (e) => { 
  world.keys[e.code] = true; 
  if (e.code === "Space") e.preventDefault();
});
window.addEventListener("keyup", (e) => { world.keys[e.code] = false; });

// Create player
const playerShape = new Polygon([
  new Vec2(-20, -20),
  new Vec2(20, -20),
  new Vec2(20, 20),
  new Vec2(-20, 20)
]);
const player = new Entity(150, 100, playerShape);
world.player = player;
world.add(player);

// Static ground
const ground = new Entity(450, 580, RotatedRect(900, 40, 0));
ground.static = true;
ground.color = "#555";
world.add(ground);

// Static slope (tilted rectangle)
const slope = new Entity(500, 500, RotatedRect(250, 40, -30));
slope.static = true;
slope.color = "#666";
world.add(slope);

// Static ceiling (for head collision testing)
const ceiling = new Entity(400, 300, RotatedRect(200, 40, 0));
ceiling.static = true;
ceiling.color = "#800";
world.add(ceiling);

world.rebuildSpatialHash();

// Sidebar controls
const toggleBtn = document.getElementById("toggle");
const sidebar = document.getElementById("sidebar");
toggleBtn.addEventListener("click", () => {
  sidebar.classList.toggle("open");
});

// Gravity control
const gravityInput = document.getElementById("gravity");
const gval = document.getElementById("gval");
gravityInput.addEventListener("input", (e) => {
  world.gravity = parseFloat(e.target.value) || 900;
  gval.textContent = world.gravity.toFixed(0);
});

// Player speed control
const speedInput = document.getElementById("speed");
const sval = document.getElementById("sval");
speedInput.addEventListener("input", (e) => {
  world.playerSpeed = parseFloat(e.target.value) || 200;
  sval.textContent = world.playerSpeed.toFixed(0);
});

// Jump height control
const jumpInput = document.getElementById("jump");
const jval = document.getElementById("jval");
jumpInput.addEventListener("input", (e) => {
  world.jumpHeight = parseFloat(e.target.value) || 400;
  jval.textContent = world.jumpHeight.toFixed(0);
});

// Debug toggle
const debugToggle = document.getElementById("debugToggle");
const dtval = document.getElementById("dtval");
debugToggle.addEventListener("change", (e) => {
  showDebug = e.target.checked;
  dtval.textContent = showDebug ? "true" : "false";
});

// Platforms control (stress test: add stacked platforms with 1px offsets)
const platformsInput = document.getElementById("platforms");
const pval = document.getElementById("pval");
platformsInput.addEventListener("input", (e) => {
  const num = parseInt(e.target.value) || 0;
  // Remove existing test platforms
  world.entities = world.entities.filter(e => !e.isTestPlatform);
  world.testPlatforms = [];
  // Add new ones with 1px vertical offsets
  if (num > 0) {
    const testShape = RotatedRect(100, 20, 0);
    const testPosX = 100;
    const testPosY = 500;
    for (let i = 0; i < num; i++) {
      const dy = -i * 0.01;
      const testPos = new Vec2(testPosX, testPosY + dy);
      const testPlatform = new Entity(testPos.x, testPos.y, testShape);
      testPlatform.static = true;
      testPlatform.color = "#f00";
      testPlatform.isTestPlatform = true;
      world.add(testPlatform);
      world.testPlatforms.push(testPlatform);
    }
  }
  world.rebuildSpatialHash();
  pval.textContent = num;
});

// Initial update
platformsInput.dispatchEvent(new Event("input"));

// ======== MAIN LOOP ========
let lastTime = 0;
function loop(currentTime) {
  frameCount++;
  if (currentTime - lastFPSTime > 1000) {
    fps = Math.round(frameCount * 1000 / (currentTime - lastFPSTime));
    frameCount = 0;
    lastFPSTime = currentTime;
  }

  const dt = Math.min((currentTime - lastTime) / 1000, 1/30);
  lastTime = currentTime;

  world.update(dt);

  // Render
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  const camX = Math.max(0, player.pos.x - canvas.width / 2);
  const camY = Math.max(0, player.pos.y - canvas.height / 2);
  ctx.translate(-camX, -camY);
  world.draw(showDebug, camX, camY);
  ctx.restore();

  // Debug overlay
  if (showDebug) {
    let keysText = "";
    if (world.keys["ArrowLeft"]) keysText += "Left ";
    if (world.keys["ArrowRight"]) keysText += "Right ";
    if (world.keys["Space"]) keysText += "Jump ";
    keysText = keysText.trim() || "None";

    debugDiv.innerHTML = `
      <b>Player Debug</b><br>
      pos: (${player.pos.x.toFixed(2)}, ${player.pos.y.toFixed(2)})<br>
      vel: (${player.vel.x.toFixed(2)}, ${player.vel.y.toFixed(2)})<br>
      onGround: ${player.onGround}<br>
      groundAngle: ${player.groundAngle.toFixed(1)}°<br>
      keys: ${keysText}<br>
      test platforms: ${world.testPlatforms.length}<br>
      fps: ${fps}
    `;
  } else {
    debugDiv.innerHTML = "";
  }

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
