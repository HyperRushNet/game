<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="icon" href="/assets/images/favicon/000000.png" media="(prefers-color-scheme: light)">  
      <link rel="icon" href="/assets/images/favicon/ffffff.png" media="(prefers-color-scheme: dark)">  
    <title>Game Engine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { overflow: hidden; background: #0a0a0a; color: #00ff41; font-family: 'Courier New', monospace; }
        canvas { background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); display: block; width: 100vw; height: 100vh; }
        #debug {
            position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.85);
            padding: 12px; border: 1px solid #00ff41; border-radius: 8px;
            width: 260px; font-size: 11px; line-height: 1.1;
            box-shadow: 0 4px 15px rgba(0, 255, 65, 0.1); backdrop-filter: blur(8px);
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="debug"></div>
    <script>
        const mapData = {
  "playerStart": {
    "x": 0,
    "y": 0,
    "w": 50,
    "h": 100,
    "zIndex": 1,
    "angle": 0
  },
  "textures": [
    "https://images.unsplash.com/photo-1542732056-648731297c97?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8c3RvbmUlMjB0ZXh0dXJlfGVufDB8fDB8fHww&fm=jpg&q=60&w=3000"
  ],
  "platforms": [
    {
      "id": "6nZuizW8hxb6-m0JFncfLJvDx",
      "type": "platform",
      "x": -15,
      "y": 101,
      "w": 2500,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 1
    },
    {
      "id": "keMuBhHTqzP2-ElDnZmfDgouW",
      "type": "platform",
      "x": -515,
      "y": -379,
      "w": 1500,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 2
    },
    {
      "id": "VejZRojgzHvF-blIm5xKkEuSc",
      "type": "wall",
      "x": 785,
      "y": -279,
      "w": 300,
      "h": 100,
      "angle": 90,
      "textureId": null,
      "zIndex": 3
    },
    {
      "id": "ou9cBmQV4oSC-wSgRFhRiTbIE",
      "type": "platform",
      "x": 1035,
      "y": -179,
      "w": 400,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 4
    },
    {
      "id": "PCRuBLJhTzCW-v5HYVKi3vRnw",
      "type": "platform",
      "x": -1215,
      "y": 343,
      "w": 385,
      "h": 100,
      "angle": 90,
      "textureId": null,
      "zIndex": 5
    },
    {
      "id": "Tt1L7zgf67Ba-qI3mYMxRomVz",
      "type": "platform",
      "x": -1315,
      "y": 161,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 6
    },
    {
      "id": "pDhcC4LYm7GM-0Te03XOwqGSy",
      "type": "wall",
      "x": -1715,
      "y": 476,
      "w": 650,
      "h": 100,
      "angle": 90,
      "textureId": null,
      "zIndex": 7
    },
    {
      "id": "LnKK92pQqrR4-WAYcIK6o0CrO",
      "type": "platform",
      "x": -1615,
      "y": 317,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 8
    },
    {
      "id": "tiw5l0HEWmNb-xkHm9MMVxoBA",
      "type": "platform",
      "x": -1315,
      "y": 525,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 9
    },
    {
      "id": "O88XGygv1w7W-P5bsK3A2BCSW",
      "type": "platform",
      "x": -1615,
      "y": 630,
      "w": 100,
      "h": 20,
      "angle": 0,
      "textureId": null,
      "zIndex": 10
    },
    {
      "id": "3aWMoOKZz9eu-g15sjN8KHSoF",
      "type": "platform",
      "x": -1265,
      "y": 851,
      "w": 1000,
      "h": 100,
      "angle": 0,
      "textureId": null,
      "zIndex": 11
    }
  ],
  "decor": [
    {
      "id": "Vrf8AG1oTEll-iltEslDgYQXm",
      "type": "decor",
      "x": 284,
      "y": -66,
      "w": 100,
      "h": 20,
      "angle": -20,
      "textureId": 0,
      "zIndex": 12,
      "parallaxSpeed": 0.7
    }
  ]
};

        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
            scale(s) { return new Vec2(this.x * s, this.y * s); }
            dot(v) { return this.x * v.x + this.y * v.y; }
            perp() { return new Vec2(-this.y, this.x); }
            len() { return Math.hypot(this.x, this.y); }
            norm() { const l = this.len(); return l ? this.scale(1 / l) : new Vec2(); }
            clone() { return new Vec2(this.x, this.y); }
        }

        function aabbOverlap(a, b) {
            return a.maxX >= b.minX && a.minX <= b.maxX && a.maxY >= b.minY && a.minY <= b.maxY;
        }

        class Polygon {
            constructor(points) {
                this.points = points.map(p => new Vec2(p.x, p.y));
                this.axes = this.getAxes();
            }
            getAxes() {
                const axes = [];
                for (let i = 0; i < this.points.length; i++) {
                    const edge = this.points[(i + 1) % this.points.length].sub(this.points[i]);
                    const axis = edge.perp().norm();
                    if (axis.len() > 0) axes.push(axis);
                }
                return axes;
            }
            getAABB(pos) {
                const pts = this.getTransformed(pos);
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of pts) {
                    minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
                }
                return { minX, minY, maxX, maxY };
            }
            getTransformed(pos) {
                return this.points.map(p => p.add(pos));
            }
            project(axis, pos) {
                const pts = this.getTransformed(pos);
                let min = Infinity, max = -Infinity;
                for (const p of pts) {
                    const proj = p.dot(axis);
                    min = Math.min(min, proj);
                    max = Math.max(max, proj);
                }
                return { min, max };
            }
            static overlap(A, posA, B, posB) {
                const axes = [...A.axes, ...B.axes];
                let overlap = Infinity, smallestAxis = null;
                for (const axis of axes) {
                    if (axis.len() < 1e-6) continue;
                    const projA = A.project(axis, posA);
                    const projB = B.project(axis, posB);
                    const o = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
                    if (o < 1e-4) return null;
                    if (o < overlap) { overlap = o; smallestAxis = axis; }
                }
                if (!smallestAxis) return null;
                const d = posA.sub(posB);
                if (d.dot(smallestAxis) < 0) smallestAxis = smallestAxis.scale(-1);
                return { axis: smallestAxis, overlap };
            }
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return new Float32Array([r, g, b, 1]);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsource, fsource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsource);
            if (!vs) return null;
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsource);
            if (!fs) return null;
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const projviewMatrix = new Float32Array(12);

        function getProjViewMatrix(width, height, camX, camY, matrix) {
            matrix[0] = 2 / width;
            matrix[1] = 0;
            matrix[2] = 0;
            matrix[3] = 0;
            matrix[4] = 0;
            matrix[5] = -2 / height;
            matrix[6] = 0;
            matrix[7] = 0;
            matrix[8] = -1 - 2 * camX / width;
            matrix[9] = 1 + 2 * camY / height;
            matrix[10] = 1;
            matrix[11] = 0;
            return matrix;
        }

        const vsSource = `#version 300 es
            precision mediump float;
            layout(std140) uniform Matrices {
                mat3 u_matrix;
            };
            layout(location = 0) in vec2 a_position;
            layout(location = 1) in vec2 a_texcoord;
            layout(location = 2) in vec4 a_color;
            out vec2 v_texcoord;
            out vec4 v_color;
            void main() {
                gl_Position = vec4((u_matrix * vec3(a_position, 1.0)).xy, 0.0, 1.0);
                v_texcoord = a_texcoord;
                v_color = a_color;
            }
        `;

        const fsSource = `#version 300 es
            precision mediump float;
            in vec2 v_texcoord;
            in vec4 v_color;
            uniform sampler2D u_texture;
            uniform bool u_useTexture;
            out vec4 fragColor;
            void main() {
                if (u_useTexture) {
                    fragColor = texture(u_texture, v_texcoord) * v_color;
                } else {
                    fragColor = v_color;
                }
            }
        `;

        function isTextureReady(texObj) {
            if (!texObj) return false;
            if (texObj instanceof HTMLImageElement) {
                return texObj.complete && texObj.naturalWidth > 0;
            } else if (texObj && texObj.video) {
                return texObj.video.readyState >= 2 && texObj.isReady;
            }
            return false;
        }

        class BaseShape {
            constructor(x, y, w, h, angleDeg, z, textureIndex, isDecor = false, parallaxSpeed = 0.7) {
                this.pos = new Vec2(x, y);
                this.prevPos = new Vec2(x, y);
                this.width = w;
                this.height = h;
                this.angle = angleDeg * Math.PI / 180;
                this.z = z || 0;
                this.textureIndex = textureIndex;
                this.isDecor = isDecor;
                this.parallaxSpeed = parallaxSpeed;
                const hw = w / 2, hh = h / 2;
                const cos = Math.cos(this.angle), sin = Math.sin(this.angle);
                this.localPoints = [
                    new Vec2(-hw * cos - hh * sin, -hw * sin + hh * cos),
                    new Vec2(hw * cos - hh * sin, hw * sin + hh * cos),
                    new Vec2(hw * cos + hh * sin, hw * sin - hh * cos),
                    new Vec2(-hw * cos + hh * sin, -hw * sin - hh * cos)
                ];
                this.shape = new Polygon(this.localPoints);
                this.updateAABB();
                this.lineArray = new Float32Array(16);
                this.colorArray = hexToRgb("#4af");
                if (!isDecor) {
                    this.vel = new Vec2(0, 0);
                    this.onGround = false;
                    this.groundNormal = new Vec2(0, -1);
                    this.oldOnGround = false;
                    this.groundAngle = 0;
                }
            }
            updateAABB() {
                const corners = this.localPoints.map(p => p.add(this.pos));
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of corners) {
                    minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
                }
                this.aabb = { minX, minY, maxX, maxY };
            }
            getTransformedPoints(pos) {
                return this.localPoints.map(p => p.add(pos));
            }
            updateLineArray(pos) {
                const pts = this.getTransformedPoints(pos);
                const la = this.lineArray;
                la[0] = pts[0].x; la[1] = pts[0].y;
                la[2] = pts[1].x; la[3] = pts[1].y;
                la[4] = pts[1].x; la[5] = pts[1].y;
                la[6] = pts[2].x; la[7] = pts[2].y;
                la[8] = pts[2].x; la[9] = pts[2].y;
                la[10] = pts[3].x; la[11] = pts[3].y;
                la[12] = pts[3].x; la[13] = pts[3].y;
                la[14] = pts[0].x; la[15] = pts[0].y;
            }
            appendDebugLines(arr, lineColor, pos, vel = null, velColor = null, startIdx = 0) {
                this.updateLineArray(pos);
                const la = this.lineArray;
                let idx = startIdx;
                for (let k = 0; k < 8; k++) {
                    const i = k * 2;
                    arr[idx++] = la[i]; arr[idx++] = la[i + 1]; arr[idx++] = 0; arr[idx++] = 0;
                    arr[idx++] = lineColor[0]; arr[idx++] = lineColor[1]; arr[idx++] = lineColor[2]; arr[idx++] = lineColor[3];
                }
                if (vel && vel.len() > 0) {
                    const scale = 0.1;
                    arr[idx++] = pos.x; arr[idx++] = pos.y; arr[idx++] = 0; arr[idx++] = 0;
                    arr[idx++] = velColor[0]; arr[idx++] = velColor[1]; arr[idx++] = velColor[2]; arr[idx++] = velColor[3];
                    arr[idx++] = pos.x + vel.x * scale; arr[idx++] = pos.y + vel.y * scale; arr[idx++] = 0; arr[idx++] = 0;
                    arr[idx++] = velColor[0]; arr[idx++] = velColor[1]; arr[idx++] = velColor[2]; arr[idx++] = velColor[3];
                }
                return idx;
            }
        }

        class Entity extends BaseShape {
            constructor(x, y, w, h, angleDeg, color, isStatic = false, z, textureIndex, parallaxSpeed) {
                super(x, y, w, h, angleDeg, z, textureIndex, false, parallaxSpeed);
                this.colorArray = hexToRgb(color);
                this.isStatic = isStatic;
                this.lastDirection = 1;
                this.dashTimer = 0;
                this.isDashing = false;
                this.dashDuration = 0.2;
                this.dashSpeed = 800;
                if (isStatic) this.updateAABB();
            }
            update(dt, world) {
                if (this.isStatic) return;
                this.oldOnGround = this.onGround;
                this.onGround = false;
                let input_speed;
                let g_vec;
                if (this.dashTimer > 0) {
                    this.dashTimer -= dt;
                    this.isDashing = true;
                    input_speed = 0;
                    g_vec = new Vec2(0, 0);
                } else {
                    this.isDashing = false;
                    input_speed = world.keys["ArrowLeft"] ? -world.playerSpeed : world.keys["ArrowRight"] ? world.playerSpeed : 0;
                    g_vec = new Vec2(0, world.gravity * dt);
                }
                const up = new Vec2(0, -1);
                if (this.oldOnGround) {
                    const tangent = this.groundNormal.perp().norm();
                    const normalComp = this.vel.dot(this.groundNormal);
                    this.vel = tangent.scale(input_speed).add(this.groundNormal.scale(normalComp));
                } else {
                    this.vel.x = input_speed;
                }
                if (this.isDashing) {
                    this.vel.x = this.lastDirection * this.dashSpeed;
                    this.vel.y = 0;
                }
                this.vel = this.vel.add(g_vec);
                const maxVel = 1000;
                const velLen = this.vel.len();
                if (velLen > maxVel) {
                    this.vel = this.vel.scale(maxVel / velLen);
                }
                const disp = this.vel.scale(dt);
                const dispLen = disp.len();
                const maxSubLen = 10;
                const numSteps = Math.max(1, Math.ceil(dispLen / maxSubLen));
                const subDisp = disp.scale(1 / numSteps);
                let currentPos = this.pos.clone();
                const beta = 0.8;
                for (let step = 0; step < numSteps; step++) {
                    let testPos = currentPos.add(subDisp);
                    for (let i = 0; i < 5; i++) {
                        let hasCollision = false;
                        const testAABB = this.shape.getAABB(testPos);
                        for (const other of world.getNearby(testPos)) {
                            if (!other.shape || other === this || other.isDecor) continue;
                            const otherAABB = other.aabb;
                            if (!aabbOverlap(testAABB, otherAABB)) continue;
                            const res = Polygon.overlap(this.shape, testPos, other.shape, other.pos);
                            if (res) {
                                hasCollision = true;
                                let axis = res.axis;
                                const d = testPos.sub(other.pos);
                                const dLen = d.len();
                                const dir = dLen > 1e-6 ? d.scale(1 / dLen) : up.clone();
                                if (dir.dot(axis) < 0) axis = axis.scale(-1);
                                testPos = testPos.add(axis.scale(beta * res.overlap));
                                const vn = this.vel.dot(axis);
                                if (vn < 0) this.vel = this.vel.sub(axis.scale(vn));
                                if (axis.dot(up) > 0.01) {
                                    this.onGround = true;
                                    this.groundNormal = axis;
                                }
                            }
                        }
                        if (!hasCollision) break;
                    }
                    currentPos = testPos;
                }
                this.prevPos = this.pos.clone();
                this.pos = currentPos;
                this.updateAABB();
                if (world.keys["Space"] && this.oldOnGround && !this.isDashing) {
                    this.vel.y = -world.jumpHeight;
                    this.vel.x = input_speed;
                    this.onGround = false;
                }
                if (this.onGround && !this.isDashing) {
                    const tangent = this.groundNormal.perp().norm();
                    this.vel = tangent.scale(input_speed);
                    const proj = this.vel.dot(up);
                    if (proj > 0) {
                        this.vel = this.vel.sub(up.scale(proj));
                    }
                    this.pos = this.pos.sub(tangent.scale(g_vec.dot(tangent) * dt));
                    this.groundAngle = Math.acos(Math.max(-1, Math.min(1, this.groundNormal.dot(up)))) * 180 / Math.PI;
                }
                if (!this.isDashing && input_speed !== 0) {
                    this.lastDirection = input_speed > 0 ? 1 : -1;
                }
            }
        }

        class World {
            constructor(gl) {
                this.gl = gl;
                this.statics = [];
                this.dynamics = [];
                this.decors = [];
                this.gravity = 900;
                this.playerSpeed = 200;
                this.jumpHeight = 600;
                this.keys = {};
                this.cellSize = 200;
                this.spatialHash = new Map();
                this.player = null;
                this.allEntities = [];
                this.batchPositionBuffer = gl.createBuffer();
                this.batchIndexBuffer = gl.createBuffer();
                this.debugLineBuffer = gl.createBuffer();
                this.vao = gl.createVertexArray();
                this.debugVao = gl.createVertexArray();
                this.maxQuads = 256;
                this.maxVerts = this.maxQuads * 4;
                this.maxIndices = this.maxQuads * 6;
                this.vertData = new Float32Array(this.maxVerts * 8);
                this.indexData = new Uint16Array(this.maxIndices);
                this.debugVertData = new Float32Array(2048);
                this.videoTextures = [];
                this.uboMatrices = null;

                this.reusableVec = new Vec2();
                this.reusablePoints = [];
                this.reusableAABB = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
                this.reusableProj = { min: 0, max: 0 };
                this.reusableAxes = [];
                this.reusableTempVec = new Vec2();
                this.reusableSubDisp = new Vec2();
                this.reusableTestPos = new Vec2();
                this.reusableDir = new Vec2();
                this.reusableTangent = new Vec2();
                this.reusableNormalComp = 0;
                this.reusableDisp = new Vec2();
                this.reusableVelLen = 0;
                this.reusableScale = 0;
                this.reusableProjUp = 0;
                this.reusableGVecDot = 0;
                this.reusableInterpPos = new Vec2();
                this.reusableOffset = new Vec2();
                this.reusableRenderPos = new Vec2();
                this.reusableDebugPos = new Vec2();
                this.reusableInterpVel = new Vec2();
                this.reusableTexCoords = new Float32Array(8); 
                this.reusableFixedTex = new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]); 
                this.reusableStandardTex = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]); 
                this.reusableCol = new Float32Array(4);
                this.reusablePointsBuf = new Float32Array(8); 
                this.reusableLineArray = new Float32Array(16);
                this.reusableVelArrowStart = new Float32Array(4);
                this.reusableVelArrowEnd = new Float32Array(4);
                this.reusableDebugVertChunk = new Float32Array(128); 
                this.reusableVertDataChunk = new Float32Array(512); 
                this.reusableIndexDataChunk = new Uint16Array(256); 
                this.reusableBatch = {indexStart: 0, numElements: 0, texIndex: -1};
                this.reusableVisibleAABB = {minX: 0, minY: 0, maxX: 0, maxY: 0 };
            }
            loadMap(data) {
                if (data.playerStart) {
                    const w = data.playerStart.w || 50;
                    const h = data.playerStart.h || 100;
                    const playerShape = new Polygon([
                        {x: -w/2, y: -h/2}, {x: w/2, y: -h/2},
                        {x: w/2, y: h/2}, {x: -w/2, y: h/2}
                    ]);
                    this.player = new Entity(data.playerStart.x || 0, data.playerStart.y || 0, w, h, data.playerStart.angle || 0, "#4af", false, data.playerStart.zIndex || 1);
                    this.player.shape = playerShape;
                    this.add(this.player);
                    this.allEntities.push(this.player);
                }
                for (const plat of data.platforms || []) {
                    const textureIndex = plat.textureId !== null ? plat.textureId : -1;
                    const color = plat.type === "wall" ? "#666" : "#555";
                    const e = new Entity(plat.x || 0, plat.y || 0, plat.w || 100, plat.h || 20, plat.angle || 0, color, true, plat.zIndex || 0, textureIndex);
                    this.add(e);
                    this.allEntities.push(e);
                }
                for (const d of data.decor || []) {
                    const dd = new BaseShape(
                        d.x || 0,
                        d.y || 0,
                        d.w || 100,
                        d.h || 100,
                        d.angle || 0,
                        d.zIndex || 0,
                        d.textureId !== null ? d.textureId : -1,
                        true,
                        d.parallaxSpeed || 0.7
                    );
                    this.decors.push(dd);
                    this.allEntities.push(dd);
                }
                this.allEntities.sort((a, b) => a.z - b.z);
                this.rebuildSpatialHash();
            }
            add(e) {
                if (e.isDecor) this.decors.push(e);
                else if (e.isStatic) this.statics.push(e);
                else this.dynamics.push(e);
            }
            getHash(pos) {
                return `${Math.floor(pos.x / this.cellSize)},${Math.floor(pos.y / this.cellSize)}`;
            }
            rebuildSpatialHash() {
                this.spatialHash.clear();
                const allStaticLike = [...this.statics, ...this.decors];
                for (const e of allStaticLike) {
                    const aabb = e.aabb;
                    const expand = e.isDecor ? 150 : 50;
                    const minX = Math.floor((aabb.minX - expand) / this.cellSize);
                    const maxX = Math.floor((aabb.maxX + expand) / this.cellSize);
                    const minY = Math.floor((aabb.minY - expand) / this.cellSize);
                    const maxY = Math.floor((aabb.maxY + expand) / this.cellSize);
                    for (let x = minX; x <= maxX; x++) {
                        for (let y = minY; y <= maxY; y++) {
                            const h = `${x},${y}`;
                            if (!this.spatialHash.has(h)) this.spatialHash.set(h, []);
                            this.spatialHash.get(h).push(e);
                        }
                    }
                }
            }
            getNearby(pos) {
                const nearby = new Set(this.dynamics);
                const cx = Math.floor(pos.x / this.cellSize), cy = Math.floor(pos.y / this.cellSize);
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const h = `${cx + dx},${cy + dy}`;
                        if (this.spatialHash.has(h)) {
                            this.spatialHash.get(h).forEach(e => {
                                if (!e.isDecor) nearby.add(e);
                            });
                        }
                    }
                }
                return Array.from(nearby);
            }
            getVisible(camX, camY, width, height) {
                const pad = 20;
                this.reusableVisibleAABB.minX = camX - pad;
                this.reusableVisibleAABB.maxX = camX + width + pad;
                this.reusableVisibleAABB.minY = camY - pad;
                this.reusableVisibleAABB.maxY = camY + height + pad;
                const visible = [];
                for (const e of this.allEntities) {
                    const aabb = e.aabb;
                    let checkMinX = aabb.minX;
                    let checkMaxX = aabb.maxX;
                    let checkMinY = aabb.minY;
                    let checkMaxY = aabb.maxY;
                    if (e.isDecor) {
                        const offsetX = camX * (1 - e.parallaxSpeed);
                        const offsetY = camY * (1 - e.parallaxSpeed);
                        checkMinX += offsetX;
                        checkMaxX += offsetX;
                        checkMinY += offsetY;
                        checkMaxY += offsetY;
                    }
                    if (checkMaxX >= this.reusableVisibleAABB.minX && checkMinX <= this.reusableVisibleAABB.maxX && checkMaxY >= this.reusableVisibleAABB.minY && checkMinY <= this.reusableVisibleAABB.maxY) {
                        visible.push(e);
                    }
                }
                if (!visible.includes(this.player)) visible.push(this.player); 
                return visible;
            }
            update(dt) {
                let moved = false;
                for (const e of this.dynamics) {
                    e.update(dt, this);
                    if (e.pos.x !== e.prevPos.x || e.pos.y !== e.prevPos.y) moved = true;
                }
            }
            getInterpolatedPosition(entity, alpha) {
                this.reusableInterpPos.x = entity.prevPos.x + (entity.pos.x - entity.prevPos.x) * alpha;
                this.reusableInterpPos.y = entity.prevPos.y + (entity.pos.y - entity.prevPos.y) * alpha;
                return this.reusableInterpPos;
            }
            getInterpolatedVel(entity, alpha) {
                return entity.vel ? entity.vel.clone() : new Vec2(0, 0);
            }
            updateVideoTextures() {
                const gl = this.gl;
                for (const texObj of this.videoTextures) {
                    if (texObj && texObj.video && texObj.isReady && !texObj.video.paused && !texObj.video.ended && texObj.video.currentTime !== texObj.lastTime) {
                        gl.bindTexture(gl.TEXTURE_2D, texObj.glTex);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texObj.video);
                        texObj.lastTime = texObj.video.currentTime;
                    }
                }
            }
            draw(debug, camX, camY, frameCount, textures, renderAlpha, width, height) {
                const gl = this.gl;
                this.updateVideoTextures();
                getProjViewMatrix(width, height, camX, camY, projviewMatrix);
                if (this.uboMatrices) {
                    gl.bindBuffer(gl.UNIFORM_BUFFER, this.uboMatrices);
                    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, projviewMatrix);
                }
                const visible = this.getVisible(camX, camY, width, height);

                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                let vertIdx = 0;
                let indexIdx = 0;
                let currentBatch = {indexStart: 0, numElements: 0, texIndex: -1};
                let batches = [];
                const whiteColor = new Float32Array([1, 1, 1, 1]);
                for (const e of visible) {
                    const interpPos = this.getInterpolatedPosition(e, renderAlpha);
                    let renderPos = interpPos.clone();
                    if (e.isDecor) {
                        const offsetX = camX * (1 - e.parallaxSpeed);
                        const offsetY = camY * (1 - e.parallaxSpeed);
                        renderPos.x += offsetX;
                        renderPos.y += offsetY;
                    }
                    let thisTex = e.textureIndex ?? -1;
                    let effectiveTex = -1;
                    let isVideoTexture = false;
                    if (thisTex >= 0) {
                        const texObj = textures[thisTex];
                        let texReady = isTextureReady(texObj);
                        let hasDims = e.width != null && e.height != null;
                        if (texReady && (e.isDecor || hasDims)) {
                            effectiveTex = thisTex;
                            isVideoTexture = texObj.video !== undefined;
                        }
                    }
                    let col = effectiveTex >= 0 ? whiteColor : e.colorArray;
                    const points = e.shape.getTransformed(renderPos);
                    const baseVert = vertIdx / 8;
                    const texCoords = isVideoTexture ? this.reusableFixedTex : this.reusableStandardTex; 
                    for (let j = 0; j < 4; j++) {
                        const p = points[j];
                        const tx = texCoords[j * 2], ty = texCoords[j * 2 + 1];
                        this.vertData[vertIdx++] = p.x;
                        this.vertData[vertIdx++] = p.y;
                        this.vertData[vertIdx++] = tx;
                        this.vertData[vertIdx++] = ty;
                        this.vertData[vertIdx++] = col[0];
                        this.vertData[vertIdx++] = col[1];
                        this.vertData[vertIdx++] = col[2];
                        this.vertData[vertIdx++] = col[3];
                    }
                    if (currentBatch.numElements > 0 && effectiveTex !== currentBatch.texIndex) {
                        batches.push({...currentBatch});
                        currentBatch = {indexStart: indexIdx, numElements: 0, texIndex: effectiveTex};
                    } else if (currentBatch.numElements === 0) {
                        currentBatch = {indexStart: indexIdx, numElements: 0, texIndex: effectiveTex};
                    }
                    currentBatch.numElements += 6;
                    const base = baseVert;
                    this.indexData[indexIdx++] = base + 0;
                    this.indexData[indexIdx++] = base + 1;
                    this.indexData[indexIdx++] = base + 2;
                    this.indexData[indexIdx++] = base + 0;
                    this.indexData[indexIdx++] = base + 2;
                    this.indexData[indexIdx++] = base + 3;
                }
                if (currentBatch.numElements > 0) batches.push({...currentBatch});

                gl.bindBuffer(gl.ARRAY_BUFFER, this.batchPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertData.subarray(0, vertIdx), gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.batchIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData.subarray(0, indexIdx), gl.DYNAMIC_DRAW);
                gl.bindVertexArray(this.vao);
                for (const b of batches) {
                    if (b.texIndex >= 0) {
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, glTextures[b.texIndex]);
                        gl.uniform1i(useTextureLoc, 1);
                    } else {
                        gl.uniform1i(useTextureLoc, 0);
                    }
                    gl.drawElements(gl.TRIANGLES, b.numElements, gl.UNSIGNED_SHORT, b.indexStart * 2);
                }
                if (debug) {
                    let debugVertIdx = 0;
                    for (const e of visible) {
                        const interpPos = this.getInterpolatedPosition(e, renderAlpha);
                        let debugPos = interpPos.clone();
                        if (e.isDecor) {
                            const offsetX = camX * (1 - e.parallaxSpeed);
                            const offsetY = camY * (1 - e.parallaxSpeed);
                            debugPos.x += offsetX;
                            debugPos.y += offsetY;
                        }
                        const interpVel = this.getInterpolatedVel(e, renderAlpha);
                        if (e.isDecor) {
                            debugVertIdx = e.appendDebugLines(this.debugVertData, cyanColor, debugPos, null, null, debugVertIdx);
                        } else {
                            debugVertIdx = e.appendDebugLines(this.debugVertData, redColor, debugPos, interpVel, greenColor, debugVertIdx);
                        }
                    }
                    if (debugVertIdx > 0) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.debugLineBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, this.debugVertData.subarray(0, debugVertIdx), gl.DYNAMIC_DRAW);
                        gl.bindVertexArray(this.debugVao);
                        gl.uniform1i(useTextureLoc, 0);
                        gl.drawArrays(gl.LINES, 0, debugVertIdx / 8);
                    }
                }
            }
        }

        const canvas = document.getElementById("game");
        const gl = canvas.getContext("webgl2", { alpha: true, desynchronized: true, powerPreference: "high-performance" });
        if (!gl) {
            alert("WebGL2 niet ondersteund");
        }
        const debugDiv = document.getElementById("debug");
        const program = createProgram(gl, vsSource, fsSource);
        if (!program) {
            alert("Shader program mislukt");
            throw new Error("Failed to create program");
        }
        gl.useProgram(program);
        const textureLoc = gl.getUniformLocation(program, "u_texture");
        const useTextureLoc = gl.getUniformLocation(program, "u_useTexture");
        gl.uniform1i(textureLoc, 0);

        const matricesBlockIndex = gl.getUniformBlockIndex(program, "Matrices");
        let uboMatrices = null;
        if (matricesBlockIndex !== gl.INVALID_INDEX) {
            gl.uniformBlockBinding(program, matricesBlockIndex, 0);
            uboMatrices = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, uboMatrices);
            gl.bufferData(gl.UNIFORM_BUFFER, 48, gl.DYNAMIC_DRAW);
            gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboMatrices);
        } else {
            console.error("Uniform block 'Matrices' not found");
        }

        const cyanColor = new Float32Array([0, 1, 1, 1]);
        const redColor = hexToRgb("#f00");
        const greenColor = new Float32Array([0, 1, 0, 1]);
        const whiteColor = new Float32Array([1, 1, 1, 1]);
        const world = new World(gl);
        world.uboMatrices = uboMatrices;

        gl.bindVertexArray(world.vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, world.batchPositionBuffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 32, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 8);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 32, 16);
        gl.enableVertexAttribArray(2);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, world.batchIndexBuffer);
        gl.bindVertexArray(null);

        gl.bindVertexArray(world.debugVao);
        gl.bindBuffer(gl.ARRAY_BUFFER, world.debugLineBuffer);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 32, 0);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 32, 8);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 32, 16);
        gl.enableVertexAttribArray(2);
        gl.bindVertexArray(null);

        const textures = [];
        const glTextures = [];
        mapData.textures.forEach((url, i) => {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([128, 128, 128, 255]));
            let textureObj;
            if (url.match(/\.(webm|mp4)$/i)) {
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.src = url;
                video.loop = true;
                video.muted = true;
                video.preload = 'auto';
                video.playbackRate = 1;
                textureObj = { video, isReady: false, glTex: tex, lastTime: 0 };
                world.videoTextures.push(textureObj);
                video.addEventListener('canplay', () => {
                    if (!textureObj.isReady) {
                        textureObj.isReady = true;
                        video.play().catch(e => console.log('Autoplay prevented:', e));
                    }
                });
                video.addEventListener('ended', () => {
                    video.currentTime = 0;
                    video.play().catch(e => {});
                });
                video.addEventListener('error', (e) => {
                    console.error('Video load error:', e);
                    textureObj.isReady = false;
                });
            } else {
                textureObj = new Image();
                textureObj.crossOrigin = "anonymous";
                textureObj.src = url;
                textureObj.onload = () => {
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureObj);
                };
                textureObj.onerror = () => console.error('Image load error');
            }
            textures.push(textureObj);
            glTextures.push(tex);
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let debugMode = false;
        window.addEventListener("keydown", e => {
            if (e.code === "KeyD") debugMode = !debugMode;
            const wasPressed = world.keys[e.code];
            world.keys[e.code] = true;
            if (!wasPressed) {
                if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
                    if (world.player.dashTimer <= 0) {
                        world.player.dashTimer = world.player.dashDuration;
                    }
                }
            }
            if (e.code === "Space") e.preventDefault();
        });
        window.addEventListener("keyup", e => world.keys[e.code] = false);

        world.loadMap(mapData);

        let lastTime = performance.now(), frameCount = 0, lastFPSTime = lastTime, fps = 60;
        let lastDebugTime = lastTime;
        let accumulator = 0;
        const fixedDT = 1 / 60;
        const maxAccumulator = fixedDT * 3;
        let camX = 0, camY = 0, prevCamX = 0, prevCamY = 0;
        const cameraSmoothing = 0.1;
        function loop(currentTime) {
            frameCount++;
            if (currentTime - lastFPSTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastFPSTime));
                frameCount = 0;
                lastFPSTime = currentTime;
            }

            const delta = Math.min((currentTime - lastTime) / 1000, 0.0333);
            lastTime = currentTime;
            accumulator += delta;
            while (accumulator >= fixedDT) {
                prevCamX = camX;
                prevCamY = camY;
                world.update(fixedDT);
                const targetCamX = world.player.pos.x - canvas.width / 2;
                const targetCamY = world.player.pos.y - canvas.height / 2;
                camX += (targetCamX - camX) * cameraSmoothing;
                camY += (targetCamY - camY) * cameraSmoothing;
                accumulator -= fixedDT;
            }

            if (accumulator > maxAccumulator) accumulator = maxAccumulator;

            const renderAlpha = accumulator / fixedDT;
            const interpCamX = prevCamX + (camX - prevCamX) * renderAlpha;
            const interpCamY = prevCamY + (camY - prevCamY) * renderAlpha;

            world.draw(debugMode, interpCamX, interpCamY, frameCount, textures, renderAlpha, canvas.width, canvas.height);
            if (currentTime - lastDebugTime >= 100 && debugMode) {
                const activeKeys = Object.keys(world.keys).filter(k => world.keys[k]).join(", ") || "None";
                const interpPos = world.getInterpolatedPosition(world.player, renderAlpha);
                debugDiv.textContent = `Player Debug\npos: (${interpPos.x.toFixed(2)}, ${interpPos.y.toFixed(2)})\nvel: (${world.player.vel.x.toFixed(2)}, ${world.player.vel.y.toFixed(2)})\nonGround: ${world.player.onGround}\ngroundAngle: ${world.player.groundAngle.toFixed(1)}°\nz: ${world.player.z}\ndashing: ${world.player.isDashing}\nkeys: ${activeKeys}\nfps: ${fps}`;
                lastDebugTime = currentTime;
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>
</html>
