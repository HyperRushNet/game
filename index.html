<!-- The Fallen Kingdom - v2.3.7 - Fixed wall and slope bugs (friction) -->
<!-- Copyright, HyperRush Network - 2025 -->
<!-- hyperrushnetwork@gmail.com -->

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>v2.3.7 - The Fallen Kingdom</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=MedievalSharp&display=swap" rel="stylesheet">
<style>
body {
    margin: 0;
    overflow: hidden;
    font-family: 'MedievalSharp', cursive;
    color: #e6d7b7;
    background: #000
}

#background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    background-color: black;
    opacity: 0.8
}

canvas {
    display: block;
    background: transparent;
    position: relative;
    z-index: 10
}

#hud {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(20, 15, 10, 0.8);
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #d4af37;
    font-size: 12px;
    z-index: 100;
    min-width: 150px
}

.ability {
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 5px
}

.ability-icon {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    color: white;
    background: #2a2a2a;
    border: 1px solid #d4af37
}

.ready {
    color: #90ee90
}

.cooldown {
    color: #ff6b6b
}

.slope-info {
    background: rgba(0, 0, 0, 0.3);
    padding: 3px 6px;
    border-radius: 3px;
    margin-top: 5px;
    font-size: 11px
}

.coords {
    font-family: 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.4);
    padding: 3px;
    border-radius: 3px;
    margin-top: 5px;
    font-size: 11px
}

.health-container {
    margin-top: 5px;
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px
}

.health-bar {
    flex: 1;
    height: 6px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 3px;
    overflow: hidden;
    border: 1px solid #d4af37
}

.health-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff0000, #00ff00);
    transition: width 0.3s ease;
    border-radius: 2px
}

#loadingScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000
}

#loadingBarContainer {
    width: min(400px, 90vw);
    height: 20px;
    background: #333;
    border: 1px solid #d4af37;
    border-radius: 10px;
    overflow: hidden;
    margin: 0 10px
}

#loadingBar {
    width: 0;
    height: 100%;
    background: #d4af37;
    transition: width 0.3s ease;
    border-radius: 8px
}

#loadingText {
    color: #e6d7b7;
    margin-top: 10px;
    font-size: clamp(14px, 4vw, 16px);
    text-shadow: 0 0 5px #d4af37;
    font-family: 'Cinzel', serif
}

.title {
    font-size: clamp(24px, 8vw, 40px);
    color: #d4af37;
    margin-bottom: 10px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    font-family: 'Cinzel', serif
}

#startButton {
    margin-top: 15px;
    padding: clamp(8px, 2vw, 10px) clamp(16px, 4vw, 20px);
    background: #d4af37;
    color: #1a0f0a;
    border: none;
    border-radius: 25px;
    font-size: clamp(14px, 4vw, 16px);
    cursor: pointer;
    display: none;
    font-family: 'Cinzel', serif;
    font-weight: 600;
    transition: background 0.3s ease;
    touch-action: manipulation
}

#fpsMeter {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(20, 15, 10, 0.8);
    color: #90ee90;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    z-index: 101;
    border: 1px solid #90ee90;
    font-size: clamp(10px, 3vw, 12px)
}

@media (max-width: 768px) {
    #hud {
        top: 5px;
        left: 5px;
        padding: 8px;
        font-size: clamp(10px, 3vw, 12px);
        min-width: auto;
        width: calc(100vw - 10px);
        max-width: 300px;
        border-radius: 6px
    }

    .ability {
        flex-wrap: wrap;
        gap: 3px
    }

    .ability-icon {
        width: 14px;
        height: 14px;
        font-size: 9px
    }

    .slope-info,
    .coords {
        font-size: clamp(9px, 2.5vw, 11px);
        padding: 2px 4px
    }

    .health-container {
        font-size: clamp(9px, 2.5vw, 11px);
        gap: 3px
    }

    .health-bar {
        height: 5px
    }

    #fpsMeter {
        top: 5px;
        right: 5px;
        padding: 4px 8px;
        font-size: clamp(9px, 2.5vw, 12px)
    }

    .title {
        margin-bottom: 5px
    }

    #loadingBarContainer {
        margin: 5px 10px
    }

    #startButton {
        margin-top: 10px
    }
}
</style>
</head>
<body>
<div id="loadingScreen">
    <div class="title">The Fallen Kingdom</div>
    <div id="loadingBarContainer">
        <div id="loadingBar"></div>
    </div>
    <div id="loadingText">Loading... 0%</div>
    <button id="startButton">Start Game</button>
</div>
<div id="background"></div>
<div id="hud">
    <div class="ability" id="dash">
        <div class="ability-icon">‚ö°</div>
        <span>Dash (Shift): Ready</span>
    </div>
    <div class="ability" id="airhop">
        <div class="ability-icon">ü¶Ö</div>
        <span>Air Hop (Space): Ready</span>
    </div>
    <div class="ability" id="block">
        <div class="ability-icon">‚öîÔ∏è</div>
        <span>Sword (C): Ready</span>
    </div>
    <div class="slope-info" id="slopeInfo">Slope: None (0¬∞)</div>
    <div class="coords" id="playerCoords">Coords: (0, 0)</div>
    <div class="health-container">
        <span>Health:</span>
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%;"></div>
        </div>
        <span id="healthText">100</span>
    </div>
</div>
<div id="fpsMeter">FPS: 0</div>
<canvas id="gameCanvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
const CONFIG = {
    gravity: 1.3,
    maxGravityAcceleration: 15,
    zIndex: {
        background: 0,
        sword: 10,
        decor: 2,
        platform: 3,
        player: 4,
        hud: 100,
        fpsMeter: 101,
        loadingScreen: 1000
    },
    parallax: {
        decor: 0.5
    },
    player: {
        width: 50,
        height: 75,
        speed: 5,
        runSpeed: 7,
        dashSpeed: 15,
        jumpVelocity: -15,
        airHopVelocity: -12,
        dashDuration: 200,
        dashCooldown: 500,
        hopCooldown: 1000,
        collisionFilter: {
            category: 0x0001,
            mask: 0x0002 | 0x0004
        }
    },
    sword: {
        width: 50,
        height: 75,
        offsetYUp: 1
    },
    camera: {
        smoothFactor: 0.2,
        bgPanSpeed: 0
    },
    culling: {
        physicsMargin: 200,
        renderMargin: 100
    },
    rotationLimit: 5,
    maxVideoResolution: {
        width: 1920,
        height: 1080
    },
    mirrorAnimations: {
        player: {
            runLeft: { axis: 'x', source: 'runRight' },
            attackLeft: { axis: 'x', source: 'attackRight' }
        },
        sword: {
            attackLeft: { axis: 'x', source: 'attackRight' }
        }
    }
};
const mapData = {
    playerStart: {
        x: 200,
        y: 150,
        w: 30,
        h: 69,
        zIndex: 1
    },
    textures: [
        "https://t4.ftcdn.net/jpg/02/92/73/13/360_F_292731351_p4objwWzlIieS2Kh7kbWVWmOhNrNE5Ft.jpg",
        "https://static.vecteezy.com/system/resources/previews/034/384/201/non_2x/hanging-vines-creepers-leaves-forest-shrubs-ai-generated-free-png.png",
        "https://t3.ftcdn.net/jpg/02/83/47/42/360_F_283474271_w1zqr8GUvlg7lTvBssUokMUYHOKdahWN.jpg"
    ],
    platforms: [
        {
            id: "s6Yv1HPc3eUC-ybFRG0L8hefN",
            type: "platform",
            x: 201,
            y: 237,
            w: 175,
            h: 20,
            angle: 0,
            textureId: 0,
            zIndex: 8
        },
        {
            id: "kF7RzTmdQULk-5BneH3VRhETy",
            type: "platform",
            x: 330,
            y: 219,
            w: 100,
            h: 20,
            angle: -20,
            textureId: 0,
            zIndex: 3
        },
        {
            id: "zjUxwpHanB7A-60LfpTyALiJX",
            type: "platform",
            x: 77,
            y: 209,
            w: 100,
            h: 20,
            angle: 35,
            textureId: 0,
            zIndex: 5
        },
        {
            id: "KuMOMQ36KB9r-qOlLnFVoEe5B",
            type: "platform",
            x: 60,
            y: 47,
            w: 100,
            h: 20,
            angle: -40,
            textureId: 0,
            zIndex: 6
        },
        {
            id: "OCSTBqgkGoOY-I7RdNYJZy56q",
            type: "wall",
            x: 34,
            y: 129,
            w: 120,
            h: 20,
            angle: 83,
            textureId: 0,
            zIndex: 8
        },
        {
            id: "baKIEEgjZfB2-nxJrhcBaoddA",
            type: "platform",
            x: 423,
            y: 194,
            w: 100,
            h: 20,
            angle: -10,
            textureId: 0,
            zIndex: 10
        },
        {
            id: "jIXg5C4C0a99-jIGFxh5iorNT",
            type: "platform",
            x: 520,
            y: 186,
            w: 100,
            h: 20,
            angle: 0,
            textureId: 0,
            zIndex: 11
        },
        {
            id: "rzWEh4ROYeQP-I0W5RRFbk6ve",
            type: "platform",
            x: 549,
            y: 73,
            w: 100,
            h: 20,
            angle: 0,
            textureId: 0,
            zIndex: 12
        },
        {
            id: "p4AyGzoIS9Gi-ruTD3jx5k2Qf",
            type: "platform",
            x: 143,
            y: 0,
            w: 100,
            h: 20,
            angle: -20,
            textureId: 0,
            zIndex: 13
        },
        {
            id: "aFhs25Nh0tJt-zo7Z6wvCZs7u",
            type: "platform",
            x: 230,
            y: 0,
            w: 100,
            h: 20,
            angle: 20,
            textureId: 0,
            zIndex: 14
        },
        {
            id: "pbfc3IfjyD9M-5uWEjQCUMNcB",
            type: "platform",
            x: 320,
            y: 8,
            w: 100,
            h: 20,
            angle: -10,
            textureId: 0,
            zIndex: 15
        },
        {
            id: "gyeIvUEBtcNQ-aNJU8WR7Wlaw",
            type: "platform",
            x: 387,
            y: 20,
            w: 70,
            h: 20,
            angle: 40,
            textureId: 0,
            zIndex: 16
        },
        {
            id: "sxmC6HrUjsvq-JuI7rT6dtDvN",
            type: "platform",
            x: 457,
            y: 57,
            w: 100,
            h: 20,
            angle: 20,
            textureId: 0,
            zIndex: 17
        },
        {
            id: "HKeOm0N7aiEh-n5yQ6gW2UD2q",
            type: "platform",
            x: 968,
            y: 271,
            w: 1000,
            h: 20,
            angle: 0,
            textureId: 0,
            zIndex: 25
        }
    ],
    decor: [
        {
            id: "nzPwEXTvixS2-zuszZnVRvBjr",
            type: "decor",
            x: 225,
            y: 21,
            w: 140,
            h: 60,
            angle: 20,
            textureId: 1,
            zIndex: 18,
            parallaxSpeed: 0.5
        },
        {
            id: "zKKSk3fVJ2tn-mGkBlxccK7Nk",
            type: "decor",
            x: 153,
            y: 26,
            w: 140,
            h: 60,
            angle: -20,
            textureId: 1,
            zIndex: 19,
            parallaxSpeed: 0.5
        },
        {
            id: "fFtAXxjPS6uG-vnlhk1Xj6Jpx",
            type: "decor",
            x: 86,
            y: 61,
            w: 140,
            h: 60,
            angle: -40,
            textureId: 1,
            zIndex: 20,
            parallaxSpeed: 0.5
        },
        {
            id: "15YKaT3kbMqg-Ruqxg8WitFAS",
            type: "decor",
            x: 320,
            y: 35,
            w: 140,
            h: 60,
            angle: -10,
            textureId: 1,
            zIndex: 21,
            parallaxSpeed: 0.5
        },
        {
            id: "Cn3zQ4hjJu1O-3mEa8yohh0c3",
            type: "decor",
            x: 381,
            y: 53,
            w: 140,
            h: 60,
            angle: 40,
            textureId: 1,
            zIndex: 22,
            parallaxSpeed: 0.5
        },
        {
            id: "hUqElZ2qVGKm-yQscx6pvTWbA",
            type: "decor",
            x: 452,
            y: 85,
            w: 140,
            h: 60,
            angle: 20,
            textureId: 1,
            zIndex: 23,
            parallaxSpeed: 0.5
        },
        {
            id: "9HGxfKBVomKg-ZijM1o6O93gp",
            type: "decor",
            x: 542,
            y: 101,
            w: 140,
            h: 60,
            angle: 0,
            textureId: 1,
            zIndex: 24,
            parallaxSpeed: 0.5
        },
        {
            id: "5nWBxxnEzyHF-RLdhIlAGnj4B",
            type: "decor",
            x: 310,
            y: 108,
            w: 589,
            h: 259,
            angle: 0,
            textureId: 2,
            zIndex: 0,
            parallaxSpeed: 0.6
        }
    ]
};
const playerAnimations = {
    idle: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    runLeft: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    runRight: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    jump: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    fall: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackUp: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackDown: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackLeft: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackRight: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm'
};
const swordAnimations = {
    attackUp: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackDown: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackLeft: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm',
    attackRight: 'https://hyperrushnet.github.io/the-fallen-kingdom/assets/animations/player/walk-right.webm'
};
const textureCache = new Map();
const videoTextures = new Map();
let soundtrack;
const assetsToLoad = [...new Set(mapData.textures.filter(src => !src.endsWith('.webm')))];
const videoUrls = mapData.textures.filter(src => src.endsWith('.webm'));
let totalAssets = assetsToLoad.length + videoUrls.length + Object.keys(playerAnimations).length + Object.keys(swordAnimations).length + 1;
let loadedAssets = 0;
const DOM = {
    canvas: document.getElementById("gameCanvas"),
    background: document.getElementById('background'),
    loadingBar: document.getElementById('loadingBar'),
    loadingText: document.getElementById('loadingText'),
    loadingScreen: document.getElementById('loadingScreen'),
    startButton: document.getElementById('startButton'),
    hud: {
        dash: document.getElementById('dash'),
        airhop: document.getElementById('airhop'),
        block: document.getElementById('block'),
        slopeInfo: document.getElementById('slopeInfo'),
        playerCoords: document.getElementById('playerCoords'),
        health: document.getElementById('healthText'),
        healthFill: document.getElementById('healthFill')
    }
};
let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight;

function preloadImages() {
    assetsToLoad.forEach(src => {
        const img = new Image();
        img.src = src;
        img.crossOrigin = "anonymous";
        img.onload = () => {
            textureCache.set(src, {
                w: img.width,
                h: img.height,
                img
            });
            loadedAssets++;
            updateLoading()
        };
        img.onerror = () => {
            loadedAssets++;
            updateLoading()
        }
    })
}

function preloadPlayerAnimations() {
    Object.entries(playerAnimations).forEach(([key, src]) => {
        const mirrorConfig = CONFIG.mirrorAnimations.player[key];
        const actualSrc = mirrorConfig ? playerAnimations[mirrorConfig.source] : src;
        const video = document.createElement('video');
        video.src = actualSrc;
        video.crossOrigin = "anonymous";
        video.muted = true;
        video.playsInline = true;
        video.preload = "auto";
        video.loop = true;
        video.addEventListener('loadedmetadata', () => {
            videoTextures.set(`player_${key}`, {
                video,
                w: video.videoWidth,
                h: video.videoHeight,
                loaded: true,
                isPlaying: false,
                mirrorAxis: mirrorConfig ? mirrorConfig.axis : null
            });
            loadedAssets++;
            updateLoading()
        });
        video.onerror = () => {
            videoTextures.set(`player_${key}`, {
                video: null,
                w: 0,
                h: 0,
                loaded: true,
                isPlaying: false,
                mirrorAxis: null
            });
            loadedAssets++;
            updateLoading()
        };
        video.load()
    })
}

function preloadSwordAnimations() {
    Object.entries(swordAnimations).forEach(([key, src]) => {
        const mirrorConfig = CONFIG.mirrorAnimations.sword[key];
        const actualSrc = mirrorConfig ? swordAnimations[mirrorConfig.source] : src;
        const video = document.createElement('video');
        video.src = actualSrc;
        video.crossOrigin = "anonymous";
        video.muted = true;
        video.playsInline = true;
        video.preload = "auto";
        video.loop = false;
        video.addEventListener('loadedmetadata', () => {
            videoTextures.set(`sword_${key}`, {
                video,
                w: video.videoWidth,
                h: video.videoHeight,
                loaded: true,
                isPlaying: false,
                duration: video.duration * 1000,
                mirrorAxis: mirrorConfig ? mirrorConfig.axis : null
            });
            loadedAssets++;
            updateLoading()
        });
        video.onerror = () => {
            videoTextures.set(`sword_${key}`, {
                video: null,
                w: 0,
                h: 0,
                loaded: true,
                isPlaying: false,
                duration: 200,
                mirrorAxis: null
            });
            loadedAssets++;
            updateLoading()
        };
        video.load()
    })
}

function setupVideoTexture(src, textureId) {
    const video = document.createElement('video');
    video.src = src;
    video.crossOrigin = "anonymous";
    video.muted = true;
    video.playsInline = true;
    video.preload = "auto";
    video.loop = false;
    video.addEventListener('loadedmetadata', () => {
        video.width = Math.min(video.videoWidth || CONFIG.maxVideoResolution.width, CONFIG.maxVideoResolution.width);
        video.height = Math.min(video.videoHeight || CONFIG.maxVideoResolution.height, CONFIG.maxVideoResolution.height);
        videoTextures.set(textureId, {
            video,
            w: video.videoWidth,
            h: video.videoHeight,
            loaded: true,
            isPlaying: false,
            duration: video.duration * 1000
        });
        loadedAssets++;
        updateLoading()
    });
    video.onerror = () => {
        videoTextures.set(textureId, {
            video: null,
            w: 0,
            h: 0,
            loaded: true,
            isPlaying: false,
            duration: 200
        });
        loadedAssets++;
        updateLoading()
    };
    video.load()
}

function updateLoading() {
    const progress = totalAssets > 0 ? Math.min((loadedAssets / totalAssets) * 100, 100) : 0;
    DOM.loadingBar.style.width = `${progress}%`;
    DOM.loadingText.textContent = `Loading... ${Math.round(progress)}%`;
    if (loadedAssets >= totalAssets) {
        setTimeout(() => {
            DOM.startButton.style.display = 'block'
        }, 500)
    }
    setTimeout(() => {
        if (loadedAssets < totalAssets) {
            loadedAssets = totalAssets;
            DOM.loadingBar.style.width = '100%';
            DOM.loadingText.textContent = 'Loading... 100%';
            DOM.startButton.style.display = 'block'
        }
    }, 10000)
}

let gameStarted = false;
let basePhysCullBounds = {
    min: { x: 0, y: 0 },
    max: { x: 0, y: 0 }
};

function startGame() {
    if (gameStarted) return;
    gameStarted = true;
    soundtrack.play().catch(e => {});
    const { Engine, Render, Runner, Bodies, World, Body, Events, Composite, Query, Vector, Bounds } = Matter;
    DOM.canvas.width = canvasWidth;
    DOM.canvas.height = canvasHeight;
    const engine = Engine.create();
    engine.world.gravity.y = CONFIG.gravity;
    const render = Render.create({
        canvas: DOM.canvas,
        engine: engine,
        options: {
            width: canvasWidth,
            height: canvasHeight,
            wireframes: false,
            background: 'transparent'
        }
    });
    const blockHitboxes = [];
    const decorBodies = [];
    let initialCamPos = { x: mapData.playerStart.x, y: mapData.playerStart.y };
    let sortedBodies = [];

    function drawBodyVideo(ctx, source, x, y, w, h, angle, mirrorAxis) {
        if (!source) return;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        if (mirrorAxis === 'x') {
            ctx.scale(-1, 1);
        } else if (mirrorAxis === 'y') {
            ctx.scale(1, -1);
        }
        ctx.drawImage(source, -w / 2, -h / 2, w, h);
        ctx.restore();
    }

    function updateVideoPlay(videoData, isVisible) {
        if (!videoData || !videoData.video) return;
        if (isVisible && !videoData.isPlaying) {
            videoData.video.play().catch(() => {});
            videoData.isPlaying = true;
        } else if (!isVisible && videoData.isPlaying) {
            videoData.video.pause();
            videoData.isPlaying = false;
        }
    }

    Render.bodies = function(render, bodies, context) {
        const c = context;
        const baseCullBounds = {
            min: { x: render.bounds.min.x - CONFIG.culling.renderMargin, y: render.bounds.min.y - CONFIG.culling.renderMargin },
            max: { x: render.bounds.max.x + CONFIG.culling.renderMargin, y: render.bounds.max.y + CONFIG.culling.renderMargin }
        };
        const allBodies = Composite.allBodies(render.engine.world);
        const visibleBodies = allBodies.filter(body => {
            if (!body || (body.render && body.render.visible === false)) return false;
            const b = body.bounds;
            if (!b) return false;
            return b.max.x > baseCullBounds.min.x && b.min.x < baseCullBounds.max.x && b.max.y > baseCullBounds.min.y && b.min.y < baseCullBounds.max.y;
        }).sort((a, b) => (a.render ? a.render.zIndex || 0 : 0) - (b.render ? b.render.zIndex || 0 : 0));
        for (let i = 0; i < visibleBodies.length; i++) {
            const body = visibleBodies[i];
            if (!body.position || (!body.circleRadius && (!body.width || !body.height))) continue;
            if (body.label === 'player' && body.playerVideo) {
                const videoData = videoTextures.get(body.videoTextureId);
                updateVideoPlay(videoData, true);
                if (videoData && videoData.loaded && videoData.video) {
                    drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle, videoData.mirrorAxis);
                } else {
                    c.save();
                    c.translate(body.position.x, body.position.y);
                    c.rotate(body.angle);
                    c.fillStyle = '#f00';
                    c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
                    c.restore();
                }
            } else if ((body.label === "platform" && body.platformVideo) || (body.label === "decor" && body.decorVideo)) {
                const videoData = videoTextures.get(body.videoTextureId);
                updateVideoPlay(videoData, true);
                if (videoData && videoData.loaded && videoData.video) {
                    drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle, null);
                } else {
                    c.save();
                    c.translate(body.position.x, body.position.y);
                    c.rotate(body.angle);
                    c.fillStyle = '#888';
                    c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
                    c.restore();
                }
            } else if (body.label === 'block_hitbox' && body.swordVideo) {
                const videoData = videoTextures.get(body.videoTextureId);
                if (videoData && videoData.loaded && videoData.video) {
                    if (!videoData.isPlaying) {
                        videoData.video.currentTime = 0;
                        videoData.video.play().catch(() => {});
                        videoData.isPlaying = true;
                    }
                    drawBodyVideo(c, videoData.video, body.position.x, body.position.y, body.videoW || body.width, body.videoH || body.height, body.angle, videoData.mirrorAxis);
                } else {
                    c.save();
                    c.translate(body.position.x, body.position.y);
                    c.rotate(body.angle);
                    c.fillStyle = '#00ff00';
                    c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
                    c.restore();
                }
            } else if (body.render.sprite && body.render.sprite.texture) {
                const img = textureCache.get(body.render.sprite.texture)?.img;
                if (img && img.complete) {
                    c.save();
                    c.translate(body.position.x, body.position.y);
                    c.rotate(body.angle);
                    c.drawImage(img, -body.width / 2, -body.height / 2, body.width, body.height);
                    c.restore();
                }
            } else if (body.render.fillStyle) {
                c.save();
                c.translate(body.position.x, body.position.y);
                c.rotate(body.angle);
                c.fillStyle = body.render.fillStyle;
                if (body.circleRadius) {
                    c.beginPath();
                    c.arc(0, 0, body.circleRadius, 0, Math.PI * 2);
                    c.fill();
                } else {
                    c.fillRect(-body.width / 2, -body.height / 2, body.width, body.height);
                }
                c.restore();
            }
        }
    };
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);
    let player = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y, mapData.playerStart.w, mapData.playerStart.h, {
        restitution: 0,
        friction: 0,
        frictionAir: 0,
        frictionStatic: 0,
        inertia: Infinity,
        render: { zIndex: CONFIG.zIndex.player },
        label: 'player',
        collisionFilter: CONFIG.player.collisionFilter,
        playerVideo: true,
        videoTextureId: 'player_idle',
        videoW: mapData.playerStart.w,
        videoH: mapData.playerStart.h,
        health: 100
    });
    player.width = mapData.playerStart.w;
    player.height = mapData.playerStart.h;
    World.add(engine.world, player);
    const groundSensor = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y + mapData.playerStart.h / 2 + 1, mapData.playerStart.w, 3, {
        isSensor: true,
        isStatic: false,
        collisionFilter: CONFIG.player.collisionFilter,
        render: { visible: false, fillStyle: 'transparent' }
    });
    groundSensor.width = mapData.playerStart.w;
    groundSensor.height = 3;
    World.add(engine.world, groundSensor);
    let camPos = { x: mapData.playerStart.x, y: mapData.playerStart.y };
    let camTarget = { x: camPos.x, y: camPos.y };
    const walls = [];
    const platforms = [];
    mapData.platforms.forEach(p => {
        let body;
        const texture = mapData.textures[p.textureId];
        const zIndex = p.zIndex || CONFIG.zIndex.platform;
        if (texture.endsWith('.webm')) {
            body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
                isStatic: true,
                restitution: 0,
                friction: 0,
                frictionStatic: 0,
                frictionAir: 0,
                label: p.type,
                angle: (p.angle || 0) * Math.PI / 180,
                collisionFilter: { category: 0x0004, mask: 0x0001 },
                render: { zIndex: zIndex }
            });
            body.platformVideo = true;
            body.videoTextureId = p.textureId;
            body.videoW = p.w;
            body.videoH = p.h;
        } else {
            const imgSize = textureCache.get(texture) || { w: p.w, h: p.h };
            body = Bodies.rectangle(p.x, p.y, p.w, p.h, {
                isStatic: true,
                restitution: 0,
                friction: 0,
                frictionStatic: 0,
                frictionAir: 0,
                render: {
                    sprite: texture ? { texture, xScale: p.w / imgSize.w, yScale: p.h / imgSize.h } : undefined,
                    fillStyle: texture ? undefined : (p.type === 'wall' ? '#444' : '#654321'),
                    zIndex: zIndex
                },
                label: p.type,
                angle: (p.angle || 0) * Math.PI / 180,
                collisionFilter: { category: 0x0004, mask: 0x0001 },
                id: p.id
            });
        }
        body.width = p.w;
        body.height = p.h;
        World.add(engine.world, body);
        if (p.type === 'wall') walls.push(body);
        if (p.type === 'platform') platforms.push(body);
        sortedBodies.push(body);
    });
    mapData.decor.forEach(d => {
        let body;
        const texture = mapData.textures[d.textureId];
        const zIndex = d.zIndex || CONFIG.zIndex.decor;
        if (texture.endsWith('.webm')) {
            body = Bodies.rectangle(d.x, d.y, d.w, d.h, {
                isStatic: false,
                isSensor: true,
                friction: 0,
                frictionStatic: 0,
                frictionAir: 0,
                label: 'decor',
                angle: (d.angle || 0) * Math.PI / 180,
                collisionFilter: { mask: 0x0000 },
                render: { zIndex: zIndex }
            });
            body.decorVideo = true;
            body.videoTextureId = d.textureId;
            body.videoW = d.w;
            body.videoH = d.h;
        } else {
            const imgSize = textureCache.get(texture) || { w: d.w, h: d.h };
            body = Bodies.rectangle(d.x, d.y, d.w, d.h, {
                isStatic: false,
                isSensor: true,
                friction: 0,
                frictionStatic: 0,
                frictionAir: 0,
                render: {
                    sprite: texture ? { texture, xScale: d.w / imgSize.w, yScale: d.h / imgSize.h } : undefined,
                    fillStyle: texture ? undefined : '#888',
                    zIndex: zIndex
                },
                label: 'decor',
                angle: (d.angle || 0) * Math.PI / 180,
                collisionFilter: { mask: 0x0000 }
            });
        }
        body.width = d.w;
        body.height = d.h;
        body.originalPos = { x: d.x, y: d.y };
        body.parallaxSpeed = d.parallaxSpeed !== undefined ? d.parallaxSpeed : CONFIG.parallax.decor;
        if (body.parallaxSpeed === 0) {
            Body.setStatic(body, true);
        } else {
            decorBodies.push(body);
        }
        World.add(engine.world, body);
        sortedBodies.push(body);
    });
    sortedBodies.sort((a, b) => (a.render ? a.render.zIndex || 0 : 0) - (b.render ? b.render.zIndex || 0 : 0));
    sortedBodies.push(player);
    const state = {
        keys: { left: false, right: false, up: false, down: false, dash: false, hop: false, sword: false, run: false },
        isDashing: false,
        dashStartTime: 0,
        lastDash: 0,
        lastHop: 0,
        isFrozen: false,
        facingDirection: 1,
        lastDirection: { x: 0, y: 0 },
        dashVelocity: { x: 0, y: 0 },
        wasInAir: false,
        currentAnimation: 'idle',
        isAttacking: false,
        attackDirection: null,
        attackStartTime: 0,
        dashHopInitiated: false
    };
    const keyMap = {
        ArrowLeft: 'left',
        ArrowRight: 'right',
        ArrowUp: 'up',
        ArrowDown: 'down',
        ShiftLeft: 'dash',
        ShiftRight: 'dash',
        Space: 'hop',
        KeyC: 'sword',
        KeyR: 'run'
    };
    let lastBlockTime = 0;
    const blockCooldown = 50;
    document.addEventListener('keydown', e => {
        if (keyMap[e.code]) state.keys[keyMap[e.code]] = true;
        if (e.code === 'KeyC') placeBlock();
    });
    document.addEventListener('keyup', e => {
        if (keyMap[e.code]) state.keys[keyMap[e.code]] = false;
    });

    function createParticles(x, y, count) {
        for (let i = 0; i < count; i++) {
            const particle = Bodies.circle(x, y, 3, {
                isStatic: false,
                label: 'particle',
                collisionFilter: { mask: 0x0000 },
                render: { fillStyle: '#ffff00' },
                friction: 0,
                frictionStatic: 0,
                frictionAir: 0
            });
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            Body.setVelocity(particle, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
            World.add(engine.world, particle);
            setTimeout(() => World.remove(engine.world, particle), 500);
        }
    }

    function placeBlock() {
        const now = Date.now();
        if (now - lastBlockTime < blockCooldown || state.isAttacking) return;
        lastBlockTime = now;
        let direction;
        if (state.keys.down) {
            direction = 'down';
        } else if (state.lastDirection.y < 0) {
            direction = 'up';
        } else if (state.lastDirection.x > 0) {
            direction = 'right';
        } else if (state.lastDirection.x < 0) {
            direction = 'left';
        } else {
            direction = 'right';
        }
        state.isAttacking = true;
        state.attackDirection = direction;
        state.attackStartTime = now;
        let blockWidth = CONFIG.sword.width;
        let blockHeight = CONFIG.sword.height;
        let blockOffsetX = 0, blockOffsetY = 0;
        const extend = CONFIG.sword.offsetYUp;
        if (direction === 'up' || direction === 'down') {
            blockHeight = player.height + CONFIG.sword.height * extend;
            if (direction === 'up') {
                blockOffsetY = -player.height / 2;
            } else {
                blockOffsetY = player.height / 2;
            }
        } else {
            blockWidth = player.width + CONFIG.sword.width * extend;
            if (direction === 'right') {
                blockOffsetX = player.width / 2;
            } else {
                blockOffsetX = -player.width / 2;
            }
        }
        const attackDir = `attack${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
        const videoTextureId = `sword_${attackDir}`;
        const videoData = videoTextures.get(videoTextureId) || { w: blockWidth, h: blockHeight, duration: 200 };
        const block = Bodies.rectangle(player.position.x + blockOffsetX, player.position.y + blockOffsetY, blockWidth, blockHeight, {
            isSensor: true,
            isStatic: false,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0,
            label: 'block_hitbox',
            render: { zIndex: CONFIG.zIndex.sword },
            collisionFilter: { mask: 0x0000 },
            swordVideo: true,
            videoTextureId: videoTextureId,
            videoW: blockWidth,
            videoH: blockHeight,
            creationTime: performance.now(),
            duration: videoData.duration || 200,
            offsetX: blockOffsetX,
            offsetY: blockOffsetY
        });
        block.width = blockWidth;
        block.height = blockHeight;
        blockHitboxes.push(block);
        World.add(engine.world, block);
        setTimeout(() => {
            if (block) {
                block.render.visible = false;
                World.remove(engine.world, block);
                const index = blockHitboxes.indexOf(block);
                if (index !== -1) blockHitboxes.splice(index, 1);
            }
            state.isAttacking = false;
            state.attackDirection = null;
            const videoData = videoTextures.get(videoTextureId);
            if (videoData && videoData.video && videoData.isPlaying) {
                videoData.video.pause();
                videoData.video.currentTime = 0;
                videoData.isPlaying = false;
            }
        }, block.duration);
        createParticles(player.position.x + blockOffsetX, player.position.y + blockOffsetY, 5);
    }

    function getVertices(body) {
        if (!body || !body.position || (!body.circleRadius && (!body.width || !body.height))) return [];
        const { position, angle } = body;
        const cos = Math.cos(angle), sin = Math.sin(angle);
        if (body.circleRadius) {
            const sides = 16;
            const vertices = [];
            for (let i = 0; i < sides; i++) {
                const theta = (i / sides) * Math.PI * 2;
                const vx = body.circleRadius * Math.cos(theta);
                const vy = body.circleRadius * Math.sin(theta);
                vertices.push({ x: vx * cos - vy * sin + position.x, y: vx * sin + vy * cos + position.y });
            }
            return vertices;
        } else {
            const hw = body.width / 2, hh = body.height / 2;
            const vertices = [
                { x: -hw, y: -hh },
                { x: hw, y: -hh },
                { x: hw, y: hh },
                { x: -hw, y: hh }
            ];
            return vertices.map(v => ({ x: v.x * cos - v.y * sin + position.x, y: v.x * sin + v.y * cos + position.y }));
        }
    }

    function projectVertices(vertices, axis) {
        let min = Infinity, max = -Infinity;
        for (const v of vertices) {
            const dot = v.x * axis.x + v.y * axis.y;
            min = Math.min(min, dot);
            max = Math.max(max, dot);
        }
        return { min, max };
    }

    function getAxes(body) {
        const vertices = getVertices(body);
        if (vertices.length === 0) return [];
        const axes = [];
        for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % vertices.length];
            const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
            const normal = { x: -edge.y, y: edge.x };
            const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            if (len === 0) continue;
            axes.push({ x: normal.x / len, y: normal.y / len });
        }
        return axes;
    }

    function satCollision(bodyA, bodyB) {
        if (!bodyA || !bodyB || !bodyA.position || !bodyB.position) return null;
        const axes = [...getAxes(bodyA), ...getAxes(bodyB)];
        if (axes.length === 0) return null;
        let mtv = null, overlap = Infinity;
        for (const axis of axes) {
            const projA = projectVertices(getVertices(bodyA), axis);
            const projB = projectVertices(getVertices(bodyB), axis);
            if (projA.max < projB.min || projB.max < projA.min) return null;
            const o = Math.min(projA.max - projB.min, projB.max - projA.min);
            if (o < overlap) {
                overlap = o;
                mtv = { axis, overlap };
            }
        }
        if (!mtv || isNaN(mtv.overlap) || isNaN(mtv.axis.x) || isNaN(mtv.axis.y)) return null;
        const aCenter = bodyA.position;
        const bCenter = bodyB.position;
        const centerDiff = { x: aCenter.x - bCenter.x, y: aCenter.y - bCenter.y };
        const dot = centerDiff.x * mtv.axis.x + centerDiff.y * mtv.axis.y;
        if (dot < 0) {
            mtv.axis.x = -mtv.axis.x;
            mtv.axis.y = -mtv.axis.y;
        }
        return mtv;
    }

    function isPlayerOnGround() {
        if (!player || !groundSensor) return { isOnGround: false, onSlope: false, slopeAngle: 0 };
        const sensorHeight = 3;
        const sensorOffsetY = player.height / 2 + 1;
        const angle = player.angle;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const sensorOffsetX = -sensorOffsetY * sin;
        const sensorOffsetYVal = sensorOffsetY * cos;
        Body.setPosition(groundSensor, { x: player.position.x + sensorOffsetX, y: player.position.y + sensorOffsetYVal });
        Body.setAngle(groundSensor, angle);
        Body.setVelocity(groundSensor, { x: 0, y: 0 });
        Body.setAngularVelocity(groundSensor, 0);
        const collidableBodies = [...platforms, ...walls].filter(b => b && b.position);
        const collisions = Query.collides(groundSensor, collidableBodies);
        let isOnGround = false, onSlope = false, slopeAngle = 0;
        let deepestCollision = null;
        let maxDepth = 0;
        for (const collision of collisions) {
            let otherBody = null;
            if (collision.bodyA && (collision.bodyA.label === 'platform' || collision.bodyA.label === 'wall')) {
                otherBody = collision.bodyA;
            } else if (collision.bodyB && (collision.bodyB.label === 'platform' || collision.bodyB.label === 'wall')) {
                otherBody = collision.bodyB;
            }
            if (otherBody && collision.normal && collision.normal.y < -0.5) {
                const depth = collision.depth || 0;
                if (depth > maxDepth) {
                    maxDepth = depth;
                    deepestCollision = otherBody;
                }
            }
        }
        if (deepestCollision) {
            isOnGround = true;
            if (deepestCollision.label === 'platform') {
                const platform = mapData.platforms.find(p => p.id === deepestCollision.id);
                if (platform && Math.abs(platform.angle) > 5) {
                    onSlope = true;
                    slopeAngle = Math.round(platform.angle);
                }
            }
        }
        return { isOnGround, onSlope, slopeAngle };
    }

    function updatePlayerAnimation() {
        const groundInfo = isPlayerOnGround();
        const velY = player ? player.velocity.y : 0;
        const now = Date.now();
        let newAnimation = state.currentAnimation;
        if (state.isAttacking && now - state.attackStartTime < (videoTextures.get(`sword_attack${state.attackDirection.charAt(0).toUpperCase() + state.attackDirection.slice(1)}`)?.duration || 200)) {
            newAnimation = `attack${state.attackDirection.charAt(0).toUpperCase() + state.attackDirection.slice(1)}`;
        } else {
            if (!groundInfo.isOnGround) {
                if (velY < -1) {
                    newAnimation = 'jump';
                } else if (velY > 1) {
                    newAnimation = 'fall';
                }
            } else {
                if (state.keys.right && !state.keys.left) {
                    newAnimation = 'runRight';
                } else if (state.keys.left && !state.keys.right) {
                    newAnimation = 'runLeft';
                } else {
                    newAnimation = 'idle';
                }
            }
        }
        if (newAnimation !== state.currentAnimation) {
            const prevVideoData = videoTextures.get(`player_${state.currentAnimation}`);
            if (prevVideoData && prevVideoData.video && prevVideoData.isPlaying) {
                prevVideoData.video.pause();
                prevVideoData.isPlaying = false;
            }
            state.currentAnimation = newAnimation;
            if (player) {
                player.videoTextureId = `player_${newAnimation}`;
            }
            const videoData = videoTextures.get(player ? player.videoTextureId : `player_${newAnimation}`);
            if (videoData && videoData.video && !videoData.isPlaying) {
                videoData.video.play().catch(() => {});
                videoData.isPlaying = true;
            }
        }
    }

    function updateHUD() {
        if (!player) return;
        const now = Date.now();
        const updateStatus = (element, name, lastTime, cooldown) => {
            const isReady = now - lastTime >= cooldown;
            element.className = `ability ${isReady ? 'ready' : 'cooldown'}`;
            element.querySelector('span').textContent = `${name}: ${isReady ? 'Ready' : 'Cooldown'}`;
        };
        updateStatus(DOM.hud.dash, 'Dash (Shift)', state.lastDash, CONFIG.player.dashCooldown);
        updateStatus(DOM.hud.airhop, 'Air Hop (Space)', state.lastHop, CONFIG.player.hopCooldown);
        DOM.hud.block.className = 'ability ready';
        DOM.hud.block.querySelector('span').textContent = `Sword (C): ${Date.now() - lastBlockTime >= blockCooldown ? 'Ready' : 'Cooldown'}`;
        const { onSlope, slopeAngle } = isPlayerOnGround();
        DOM.hud.slopeInfo.textContent = onSlope ? `Slope: Active (${slopeAngle}¬∞)` : `Slope: None (0¬∞)`;
        DOM.hud.slopeInfo.className = onSlope ? 'slope-info ready' : 'slope-info';
        DOM.hud.playerCoords.textContent = `Coords: (${Math.round(player.position.x)}, ${Math.round(player.position.y)})`;
        const healthPercent = (player.health / 100) * 100;
        DOM.hud.health.textContent = Math.round(player.health);
        DOM.hud.healthFill.style.width = `${healthPercent}%`;
    }

    window.addEventListener('resize', () => {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        DOM.canvas.width = canvasWidth;
        DOM.canvas.height = canvasHeight;
        render.options.width = canvasWidth;
        render.options.height = canvasHeight;
    });
    Render.lookAt(render, {
        min: { x: mapData.playerStart.x - canvasWidth / 2, y: mapData.playerStart.y - canvasHeight / 2 },
        max: { x: mapData.playerStart.x + canvasWidth / 2, y: mapData.playerStart.y + canvasHeight / 2 }
    });
    let lastTime = performance.now();
    let frames = 0;
    let fps = 0;

    function updateFPS() {
        const now = performance.now();
        frames++;
        if (now - lastTime >= 1000) {
            fps = frames;
            frames = 0;
            lastTime = now;
            document.getElementById('fpsMeter').textContent = 'FPS: ' + fps;
        }
        requestAnimationFrame(updateFPS);
    }
    updateFPS();

    function endDash() {
        if (state.isDashing) {
            state.isDashing = false;
            state.lastDash = Date.now();
            const postDashSpeed = CONFIG.player.speed;
            if (state.dashHopInitiated) {
                const dashDirection = state.dashVelocity.x > 0 ? 1 : -1;
                Body.setVelocity(player, { x: dashDirection * postDashSpeed, y: player.velocity.y });
            } else {
                const magnitude = Math.sqrt(state.dashVelocity.x ** 2 + state.dashVelocity.y ** 2);
                const scaledX = magnitude > 0 ? state.dashVelocity.x * (postDashSpeed / magnitude) : 0;
                const scaledY = magnitude > 0 ? state.dashVelocity.y * (postDashSpeed / magnitude) : 0;
                Body.setVelocity(player, { x: scaledX, y: scaledY });
            }
            player.force = { x: 0, y: 0 };
            state.dashHopInitiated = false;
        }
    }

    let lastGroundState = { isOnGround: false, onSlope: false, slopeAngle: 0 };
    let slopeFrameCount = 0;
    const hysteresisFrames = 3;
    let previousPlayerState = {
        position: { x: mapData.playerStart.x, y: mapData.playerStart.y },
        velocity: { x: 0, y: 0 },
        angle: 0
    };
    Events.on(engine, 'beforeUpdate', () => {
        if (!player) return;
        previousPlayerState = { position: { ...player.position }, velocity: { ...player.velocity }, angle: player.angle };
        const now = Date.now();
        updatePlayerAnimation();
        if (state.keys.right && !state.keys.left) {
            state.facingDirection = 1;
            state.lastDirection = { x: 1, y: 0 };
        } else if (state.keys.left && !state.keys.right) {
            state.facingDirection = -1;
            state.lastDirection = { x: -1, y: 0 };
        } else if (state.keys.up && !state.keys.right && !state.keys.left) {
            state.lastDirection = { x: 0, y: -1 };
        }
        const groundInfo = isPlayerOnGround();
        const justLanded = !lastGroundState.isOnGround && groundInfo.isOnGround;
        const maxTilt = CONFIG.rotationLimit * Math.PI / 180;
        if (groundInfo.onSlope) {
            slopeFrameCount = Math.min(slopeFrameCount + 1, hysteresisFrames);
        } else {
            slopeFrameCount = Math.max(slopeFrameCount - 1, 0);
        }
        groundInfo.onSlope = slopeFrameCount >= hysteresisFrames;
        if (!groundInfo.onSlope) groundInfo.slopeAngle = 0;
        let targetAngle = groundInfo.onSlope ? groundInfo.slopeAngle * Math.PI / 180 : 0;
        targetAngle = Math.max(-maxTilt * 10, Math.min(targetAngle, maxTilt * 10));
        let lerpSpeed = 0.1;
        if (justLanded && groundInfo.onSlope) {
            lerpSpeed = 0.3;
        }
        const newPlayerAngle = player.angle + (targetAngle - player.angle) * lerpSpeed;
        Body.setAngle(player, newPlayerAngle);
        const sensorOffsetYVal = player.height / 2 + 1;
        const angle = player.angle;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const groundSensorOffsetX = -sensorOffsetYVal * sin;
        const groundSensorOffsetY = sensorOffsetYVal * cos;
        Body.setPosition(groundSensor, { x: player.position.x + groundSensorOffsetX, y: player.position.y + groundSensorOffsetY });
        Body.setAngle(groundSensor, angle);
        Body.setVelocity(groundSensor, { x: 0, y: 0 });
        Body.setAngularVelocity(groundSensor, 0);
        lastGroundState = groundInfo;
        state.wasInAir = !groundInfo.isOnGround;
        if (state.isDashing && now - state.dashStartTime < CONFIG.player.dashDuration) {
            if (state.dashHopInitiated) {
                Body.setVelocity(player, { x: state.dashVelocity.x, y: player.velocity.y });
                player.force = { x: 0, y: 0 };
            } else {
                const g = engine.world.gravity;
                player.force.y = -(g.y * g.scale * player.mass);
                player.force.x = 0;
            }
        } else if (state.isDashing) {
            endDash();
        }
        if (state.keys.dash && !state.isDashing && now - state.lastDash >= CONFIG.player.dashCooldown) {
            const dir = state.keys.right ? 1 : state.keys.left ? -1 : state.facingDirection;
            let dashVx = dir * CONFIG.player.dashSpeed;
            let dashVy = 0;
            if (groundInfo.isOnGround && groundInfo.onSlope) {
                const theta = groundInfo.slopeAngle * Math.PI / 180;
                dashVx = dir * CONFIG.player.dashSpeed * Math.cos(theta);
                dashVy = dir * CONFIG.player.dashSpeed * Math.sin(theta);
            }
            state.dashVelocity = { x: dashVx, y: dashVy };
            Body.setVelocity(player, state.dashVelocity);
            state.isDashing = true;
            state.dashStartTime = now;
            state.dashHopInitiated = false;
            player.frictionAir = 0;
            setTimeout(endDash, CONFIG.player.dashDuration);
        }
        if (!state.isDashing) {
            const input = (state.keys.right ? 1 : 0) - (state.keys.left ? 1 : 0);
            const speed = state.keys.run ? CONFIG.player.runSpeed : CONFIG.player.speed;
            let targetVelX = input * speed;
            let targetVelY = 0;
            if (groundInfo.isOnGround && groundInfo.onSlope) {
                const theta = groundInfo.slopeAngle * Math.PI / 180;
                targetVelX = input * speed * Math.cos(theta);
                targetVelY = input * speed * Math.sin(theta);
            }
            if (groundInfo.isOnGround) {
                Body.setVelocity(player, { x: targetVelX, y: targetVelY });
            } else {
                Body.setVelocity(player, { x: player.velocity.x + (targetVelX - player.velocity.x) * 0.1, y: player.velocity.y });
            }
            if (state.keys.right) state.facingDirection = 1;
            if (state.keys.left) state.facingDirection = -1;
        }
        if (state.keys.hop && !groundInfo.isOnGround && now - state.lastHop >= CONFIG.player.hopCooldown) {
            const hopVelocity = state.isDashing ? CONFIG.player.jumpVelocity : CONFIG.player.airHopVelocity;
            Body.setVelocity(player, { x: player.velocity.x, y: hopVelocity });
            state.lastHop = now;
            if (state.isDashing) {
                state.dashHopInitiated = true;
            }
        }
        if (state.keys.up && groundInfo.isOnGround) {
            Body.setVelocity(player, { x: player.velocity.x, y: CONFIG.player.jumpVelocity });
        }
        if (!state.isDashing && !groundInfo.isOnGround) {
            const maxFallSpeed = CONFIG.maxGravityAcceleration;
            if (player.velocity.y > maxFallSpeed) {
                Body.setVelocity(player, { x: player.velocity.x, y: maxFallSpeed });
            }
        }
        let wallCollision = false;
        const obstacles = [...walls, ...platforms].filter(b => b && b.position);
        obstacles.forEach(obstacle => {
            if (!obstacle.position || (!obstacle.circleRadius && (!obstacle.width || !obstacle.height))) return;
            const mtv = satCollision(player, obstacle);
            if (mtv && mtv.overlap > 0.1) {
                const pos = player.position;
                Body.setPosition(player, { x: pos.x + mtv.axis.x * mtv.overlap * 1.01, y: pos.y + mtv.axis.y * mtv.overlap * 1.01 });
                const vel = player.velocity;
                const dot = vel.x * mtv.axis.x + vel.y * mtv.axis.y;
                if (dot < 0) {
                    const normalVel = { x: dot * mtv.axis.x, y: dot * mtv.axis.y };
                    let newVelX = vel.x - normalVel.x;
                    let newVelY = vel.y - normalVel.y;
                    if (groundInfo.isOnGround && Math.abs(mtv.axis.x) > 0.7) {
                        newVelX = vel.x;
                    }
                    if (state.isDashing && Math.abs(mtv.axis.x) > 0.7) {
                        endDash();
                        newVelX = Math.abs(mtv.axis.x) > 0.9 ? 0 : newVelX;
                        newVelY = Math.abs(mtv.axis.y) > 0.9 ? 0 : newVelY;
                    }
                    Body.setVelocity(player, { x: newVelX, y: newVelY });
                }
                wallCollision = true;
            }
        });
        camTarget.x = player.position.x;
        camTarget.y = player.position.y;
        camPos.x += (camTarget.x - camPos.x) * CONFIG.camera.smoothFactor;
        camPos.y += (camTarget.y - camPos.y) * CONFIG.camera.smoothFactor;
        decorBodies.forEach(body => {
            if (!body) return;
            const speed = body.parallaxSpeed;
            const parallaxOffsetX = (camPos.x - initialCamPos.x) * speed;
            const parallaxOffsetY = (camPos.y - initialCamPos.y) * speed;
            const newPos = { x: body.originalPos.x + parallaxOffsetX, y: body.originalPos.y + parallaxOffsetY };
            const delta = Vector.sub(newPos, body.position);
            if (Math.abs(delta.x) > 0.001 || Math.abs(delta.y) > 0.001) {
                Body.translate(body, delta);
            }
            Body.setVelocity(body, { x: 0, y: 0 });
            Body.setAngularVelocity(body, 0);
        });
        const camX = camPos.x - canvasWidth / 2;
        const camY = camPos.y - canvasHeight / 2;
        render.bounds.min.x = camX;
        render.bounds.min.y = camY;
        render.bounds.max.x = camX + canvasWidth;
        render.bounds.max.y = camY + canvasHeight;
        const basePhysMargin = CONFIG.culling.physicsMargin;
        basePhysCullBounds = {
            min: { x: camX - basePhysMargin, y: camY - basePhysMargin },
            max: { x: camX + canvasWidth + basePhysMargin, y: camY + canvasHeight + basePhysMargin }
        };
        const bodies = Composite.allBodies(engine.world).filter(b => b && b.position);
        bodies.forEach(body => {
            if (body.label === 'player') return;
            const b = body.bounds;
            if (!b) return;
            const physCullBounds = basePhysCullBounds;
            const inPhysView = b.max.x > physCullBounds.min.x && b.min.x < physCullBounds.max.x && b.max.y > physCullBounds.min.y && b.min.y < physCullBounds.max.y;
            if (inPhysView) {
                if (body.label === 'platform' || body.label === 'slope') body.collisionFilter.mask = 0x0001;
            } else {
                body.collisionFilter.mask = 0x0000;
                if (body.platformVideo || body.decorVideo) {
                    const videoData = videoTextures.get(body.videoTextureId);
                    updateVideoPlay(videoData, false);
                }
            }
        });
        if (isNaN(player.position.x) || isNaN(player.position.y) || isNaN(player.velocity.x) || isNaN(player.velocity.y) || isNaN(player.angle)) {
            Body.setPosition(player, previousPlayerState.position);
            Body.setVelocity(player, previousPlayerState.velocity);
            Body.setAngle(player, previousPlayerState.angle);
        }
    });
    Events.on(engine, 'afterUpdate', () => {
        blockHitboxes.forEach(block => {
            if (!block || !player) return;
            const playerAngle = player.angle;
            const cos = Math.cos(playerAngle);
            const sin = Math.sin(playerAngle);
            const rotatedOffsetX = block.offsetX * cos - block.offsetY * sin;
            const rotatedOffsetY = block.offsetX * sin + block.offsetY * cos;
            Body.setPosition(block, { x: player.position.x + rotatedOffsetX, y: player.position.y + rotatedOffsetY });
            Body.setAngle(block, playerAngle);
            Body.setVelocity(block, { x: 0, y: 0 });
            Body.setAngularVelocity(block, 0);
        });
    });
    setInterval(updateHUD, 100);
};
preloadImages();
mapData.textures.forEach((src, index) => {
    if (src.endsWith('.webm')) {
        setupVideoTexture(src, index);
    }
});
preloadPlayerAnimations();
preloadSwordAnimations();
soundtrack = new Audio('https://github.com/HyperRushNet/game/releases/download/soundtrack/soundtrack.mp3');
soundtrack.loop = true;
soundtrack.volume = 1;
soundtrack.preload = "auto";
soundtrack.addEventListener('canplaythrough', () => {
    loadedAssets++;
    updateLoading();
});
soundtrack.onerror = () => {
    loadedAssets++;
    updateLoading();
};
soundtrack.load();
DOM.startButton.addEventListener('click', () => {
    DOM.loadingScreen.style.display = 'none';
    startGame();
});
</script>
</body>
</html>
