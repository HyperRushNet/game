<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Runner - Map Executor with Slopes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            color: white;
        }
        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-image: url('https://www.shutterstock.com/blog/wp-content/uploads/sites/5/2021/01/shutterstock_112280795.jpg?w=750');
            background-repeat: repeat;
            background-size: 350px 350px;
            filter: brightness(50%);
        }
        canvas {
            display: block;
            background: transparent;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 1;
        }
        .ability {
            margin-bottom: 5px;
        }
        .ready {
            color: #0f0;
        }
        .cooldown {
            color: #f00;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #loadingBarContainer {
            width: 300px;
            height: 20px;
            background: #333;
            border: 1px solid #666;
            border-radius: 10px;
            overflow: hidden;
        }
        #loadingBar {
            width: 0%;
            height: 100%;
            background: #0f0;
            transition: width 0.3s ease;
        }
        #loadingText {
            color: white;
            margin-top: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingBarContainer">
            <div id="loadingBar"></div>
        </div>
        <div id="loadingText">Laden... 0%</div>
    </div>
    <div id="background"></div>
    <div id="hud">
        <div class="ability" id="dash">Dash (Shift): Ready</div>
        <div class="ability" id="airhop">Air Hop (Space): Ready</div>
        <div class="ability" id="teleport">Teleport (blauw): Ready</div>
        <div class="ability" id="sword">Sword (C): Ready</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
    <script>
        const mapData = {
            playerStart: { x: 200, y: -100 },
            textures: [
                'https://placehold.co/2000x20/654321/ffffff/png?text=Main+Platform',
                'https://placehold.co/400x20/00ff00/ffffff/png?text=Slope+1',
                'https://placehold.co/400x20/ff0000/ffffff/png?text=Slope+2'
            ],
            platforms: [
                { x: 1000, y: 200, w: 2000, h: 20, id: 'mainPlatform', angle: 0, textureId: 0 },
                { x: 2500, y: 150, w: 400, h: 20, id: 'slope1', angle: 0.5236, textureId: 1 },
                { x: 3000, y: 250, w: 400, h: 20, id: 'slope2', angle: -0.5236, textureId: 2 }
            ],
            enemies: []
        };

        const swordImageUrl = 'https://hyperrushnet.github.io/v3concept/sword-image-game-no-bg.png';

        // Verzamel alle unieke images
        const imagesToLoad = [...new Set([...mapData.textures, swordImageUrl])];
        let imagesLoaded = 0;
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');
        const loadingScreen = document.getElementById('loadingScreen');

        // Cache voor image sizes
        const textureCache = {};

        function preloadImages() {
            imagesToLoad.forEach(src => {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    textureCache[src] = { w: img.width, h: img.height };
                    imagesLoaded++;
                    updateLoading();
                };
                img.onerror = () => {
                    console.error(`Fout bij laden van afbeelding: ${src}`);
                    imagesLoaded++;
                    updateLoading();
                };
            });
        }

        function updateLoading() {
            const progress = (imagesLoaded / imagesToLoad.length) * 100;
            loadingBar.style.width = `${progress}%`;
            loadingText.textContent = `Laden... ${Math.round(progress)}%`;
            if (imagesLoaded === imagesToLoad.length) {
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    startGame();
                }, 500);
            }
        }

        function startGame() {
            const { Engine, Render, Runner, Bodies, World, Body, Events, Composite, Query } = Matter;
            const canvas = document.getElementById("gameCanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const hud = {
                dash: document.getElementById('dash'),
                airhop: document.getElementById('airhop'),
                teleport: document.getElementById('teleport'),
                sword: document.getElementById('sword'),
            };

            const backgroundDiv = document.getElementById('background');
            const engine = Engine.create();
            engine.world.gravity.y = 1.2;
            const world = engine.world;

            const render = Render.create({
                canvas: canvas,
                engine: engine,
                options: { width: canvasWidth, height: canvasHeight, wireframes: false, background: 'transparent' }
            });

            Render.run(render);
            Runner.run(Runner.create(), engine);

            const playerOptions = {
                restitution: 0,
                friction: 0.01,
                frictionAir: 0.02,
                render: { fillStyle: '#f00' },
                label: 'player',
                inertia: Infinity,
                collisionFilter: { category: 0x0001, mask: 0x0002 | 0x0004 }
            };

            let player = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y, 50, 50, playerOptions);
            World.add(world, player);

            // ⬇️ Camera variabelen voor smooth follow
            let camTarget = { x: mapData.playerStart.x, y: mapData.playerStart.y };
            let camPos = { x: camTarget.x, y: camTarget.y };

            const platforms = {};
            mapData.platforms.forEach(p => {
                const texture = mapData.textures[p.textureId] || null;
                const imgSize = textureCache[texture] || { w: p.w, h: p.h };

                const platformOptions = {
                    isStatic: true,
                    restitution: 0,
                    render: texture ? {
                        sprite: {
                            texture: texture,
                            xScale: p.w / imgSize.w, // vervormen breedte
                            yScale: p.h / imgSize.h  // vervormen hoogte
                        }
                    } : { fillStyle: '#654321' },
                    label: p.angle !== 0 ? 'slope' : 'static-platform',
                    angle: p.angle || 0,
                    collisionFilter: { category: 0x0002, mask: 0x0001 }
                };
                const platformBody = Bodies.rectangle(p.x, p.y, p.w, p.h, platformOptions);
                if (p.angle) {
                    Body.setAngle(platformBody, p.angle);
                }
                platformBody.id = p.id;
                platforms[p.id] = platformBody;
                World.add(world, platformBody);
            });

            const teleporters = {};
            const movingPlatforms = [];
            const enemies = [];

            mapData.enemies.forEach(e => {
                const enemyOptions = {
                    restitution: 0,
                    render: { fillStyle: '#0f0' },
                    label: 'enemy',
                    collisionFilter: { category: 0x0004, mask: 0x0001 | 0x0008 }
                };
                const enemyBody = Bodies.rectangle(e.x, e.y, e.w, e.h, enemyOptions);
                enemyBody.id = e.id;
                enemies.push(enemyBody);
                World.add(world, enemyBody);
            });

            const keys = { left: false, right: false, up: false, dash: false, hop: false, sword: false };
            let activeSword = null;
            let lastDash = 0, dashDuration = 100, dashCooldown = 2000, isDashing = false, dashStartTime = 0;
            let lastHop = 0, hopCooldown = 1500;
            let lastTeleport = 0, teleportCooldown = 2000;
            let isFrozen = false;
            let targetPlayerAngle = 0;
            const rotationSpeed = 0.2;

            let lastPlayerPosition = { x: player.position.x, y: player.position.y };

            document.addEventListener('keydown', e => {
                if (e.code === 'ArrowLeft') keys.left = true;
                if (e.code === 'ArrowRight') keys.right = true;
                if (e.code === 'ArrowUp') keys.up = true;
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.dash = true;
                if (e.code === 'Space') keys.hop = true;
                if (e.code === 'KeyC') { keys.sword = true; startSwordSwing(); }
            });

            document.addEventListener('keyup', e => {
                if (e.code === 'ArrowLeft') keys.left = false;
                if (e.code === 'ArrowRight') keys.right = false;
                if (e.code === 'ArrowUp') keys.up = false;
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.dash = false;
                if (e.code === 'Space') keys.hop = false;
                if (e.code === 'KeyC') keys.sword = false;
            });

            function isPlayerOnGround() {
                const sensor = Bodies.rectangle(player.position.x, player.bounds.max.y + 5, 10, 10, {
                    isSensor: true,
                    isStatic: true,
                    collisionFilter: { category: 0x0010, mask: 0x0002 }
                });
                const collisions = Query.collides(sensor, Composite.allBodies(world));
                World.remove(world, sensor);
                let groundAngle = 0;
                const isOnGround = collisions.some(c => {
                    const other = (c.bodyA === sensor) ? c.bodyB : c.bodyA;
                    if (other.label === 'static-platform' || other.label === 'slope' || other.label === 'moving-platform') {
                        groundAngle = other.angle || 0;
                        return true;
                    }
                    return false;
                });
                return { isOnGround, groundAngle };
            }

            function startSwordSwing() {
                if (activeSword) return;
                const dir = keys.left ? -1 : 1;
                const offsetX = dir * 35;
                const offsetY = 0;
                const swordImg = new Image();
                swordImg.src = swordImageUrl;
                swordImg.onload = () => {
                    const originalWidth = swordImg.width;
                    const originalHeight = swordImg.height;
                    const targetHeight = 25;
                    const scale = targetHeight / originalHeight;
                    const targetWidth = originalWidth * scale;
                    const playerAngle = player.angle || 0;
                    const cosAngle = Math.cos(playerAngle);
                    const sinAngle = Math.sin(playerAngle);
                    const swordX = player.position.x + (offsetX * cosAngle - offsetY * sinAngle);
                    const swordY = player.position.y + (offsetX * sinAngle + offsetY * cosAngle);
                    const sword = Bodies.rectangle(swordX, swordY, targetWidth, targetHeight, {
                        isSensor: true,
                        restitution: 0,
                        render: { sprite: { texture: swordImg.src, xScale: scale, yScale: scale } },
                        label: 'sword',
                        collisionFilter: { category: 0x0008, mask: 0x0004 }
                    });
                    sword.dir = dir;
                    sword.offsetX = offsetX;
                    sword.offsetY = offsetY;
                    sword.swingAngle = dir === 1 ? -Math.PI / 4 : -3 * Math.PI / 4;
                    activeSword = sword;
                    World.add(world, sword);
                    Body.setAngle(sword, sword.swingAngle + playerAngle);
                    const swingDuration = 200;
                    const swingArc = Math.PI / 2;
                    const step = swingArc / (swingDuration / 16) * dir;
                    let elapsed = 0;
                    const interval = setInterval(() => {
                        elapsed += 16;
                        sword.swingAngle += step;
                        if (elapsed >= swingDuration) {
                            World.remove(world, sword);
                            activeSword = null;
                            clearInterval(interval);
                        }
                    }, 16);
                };
            }

            function updateHUD() {
                const now = Date.now();
                hud.dash.className = `ability ${now - lastDash >= dashCooldown ? 'ready' : 'cooldown'}`;
                hud.airhop.className = `ability ${now - lastHop >= hopCooldown ? 'ready' : 'cooldown'}`;
                hud.teleport.className = `ability ${now - lastTeleport >= teleportCooldown ? 'ready' : 'cooldown'}`;
                hud.sword.className = 'ability ready';
                hud.dash.textContent = `Dash (Shift): ${now - lastDash >= dashCooldown ? 'Ready' : 'Cooldown'}`;
                hud.airhop.textContent = `Air Hop (Space): ${now - lastHop >= hopCooldown ? 'Ready' : 'Cooldown'}`;
                hud.teleport.textContent = `Teleport (blauw): ${now - lastTeleport >= teleportCooldown ? 'Ready' : 'Cooldown'}`;
                hud.sword.textContent = `Sword (C): Ready`;
            }

            setInterval(updateHUD, 100);

            function resetGame() {
                World.clear(world, false);
                Object.values(platforms).forEach(p => {
                    World.add(world, p);
                    if (p.angle) Body.setAngle(p, p.angle);
                });
                player = Bodies.rectangle(mapData.playerStart.x, mapData.playerStart.y, 50, 50, playerOptions);
                World.add(world, player);
                enemies.forEach(e => World.add(world, e));
                lastPlayerPosition = { x: player.position.x, y: player.position.y };
            }

            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    if ((bodyA.label === 'player' && bodyB.label === 'enemy') || (bodyB.label === 'player' && bodyA.label === 'enemy')) {
                        resetGame();
                    }
                    if (activeSword && ((bodyA.label === 'sword' && bodyB.label === 'enemy') || (bodyA.label === 'enemy' && bodyB.label === 'sword'))) {
                        const enemyBody = bodyA.label === 'enemy' ? bodyA : bodyB;
                        World.remove(world, enemyBody);
                        const index = enemies.indexOf(enemyBody);
                        if (index > -1) enemies.splice(index, 1);
                    }
                });
            });

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                Render.lookAt(render, {
                    min: { x: 0, y: 0 },
                    max: { x: canvas.width, y: canvas.height }
                });
            });

            Events.on(engine, 'beforeUpdate', () => {
                const now = Date.now();
                const speed = 5, dashSpeed = 15;

                if (!isFrozen) {
                    const canDashNow = now - lastDash >= dashCooldown;
                    if (keys.dash && !isDashing && canDashNow) {
                        let dashDir = 0;
                        if (keys.left) dashDir = -dashSpeed;
                        if (keys.right) dashDir = dashSpeed;
                        if (dashDir !== 0) {
                            Body.setVelocity(player, { x: dashDir, y: player.velocity.y });
                            isDashing = true;
                            dashStartTime = now;
                            lastDash = now;
                        }
                    }
                    if (isDashing && now - dashStartTime >= dashDuration) {
                        isDashing = false;
                        Body.setVelocity(player, { x: 0, y: player.velocity.y });
                    }
                    if (keys.hop && !isPlayerOnGround().isOnGround && now - lastHop >= hopCooldown) {
                        Body.setVelocity(player, { x: player.velocity.x, y: -12 });
                        lastHop = now;
                    }
                    if (!isDashing) {
                        const curr = player.velocity.x;
                        const target = (keys.right ? speed : 0) - (keys.left ? speed : 0);
                        Body.setVelocity(player, { x: curr + (target - curr) * 0.2, y: player.velocity.y });
                    }
                    if (keys.up && isPlayerOnGround().isOnGround) {
                        Body.setVelocity(player, { x: player.velocity.x, y: -15 });
                    }
                }

                const { isOnGround, groundAngle } = isPlayerOnGround();
                targetPlayerAngle = isOnGround ? groundAngle : 0;
                const currentAngle = player.angle;
                const angleDiff = targetPlayerAngle - currentAngle;
                let normalizedDiff = angleDiff - (2 * Math.PI * Math.round(angleDiff / (2 * Math.PI)));
                if (Math.abs(normalizedDiff) < rotationSpeed) {
                    Body.setAngle(player, targetPlayerAngle);
                } else {
                    Body.setAngle(player, currentAngle + Math.sign(normalizedDiff) * rotationSpeed);
                }

                if (activeSword) {
                    const playerAngle = player.angle || 0;
                    const cosAngle = Math.cos(playerAngle);
                    const sinAngle = Math.sin(playerAngle);
                    const swordX = player.position.x + (activeSword.offsetX * cosAngle - activeSword.offsetY * sinAngle);
                    const swordY = player.position.y + (activeSword.offsetX * sinAngle + activeSword.offsetY * cosAngle);
                    Body.setPosition(activeSword, { x: swordX, y: swordY });
                    Body.setAngle(activeSword, activeSword.swingAngle + playerAngle);
                }

                // Smooth camera follow
                camTarget.x = player.position.x;
                camTarget.y = player.position.y;

                const smoothFactor = 0.1; // hoe lager, hoe smoother
                camPos.x += (camTarget.x - camPos.x) * smoothFactor;
                camPos.y += (camTarget.y - camPos.y) * smoothFactor;

                const camX = camPos.x - canvasWidth / 2;
                const camY = camPos.y - canvasHeight / 2;

                render.bounds.min.x = camX;
                render.bounds.min.y = camY;
                render.bounds.max.x = camX + canvasWidth;
                render.bounds.max.y = camY + canvasHeight;

                Render.lookAt(render, {
                    min: { x: camX, y: camY },
                    max: { x: camX + canvasWidth, y: camY + canvasHeight }
                });

                // Parallax achtergrond
                const bgPanSpeed = 0.5;
                backgroundDiv.style.backgroundPosition = `${-camX * bgPanSpeed}px ${-camY * bgPanSpeed}px`;
            });
        }

        preloadImages();
    </script>
</body>
</html>
