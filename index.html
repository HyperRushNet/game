<!-- The Fallen Kingdom - Still in development! -->
<!-- 2025 - HyperRush Network - Do not use this code without permission from hyperrushnetwork@gmail.com -->

<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Fallen Kingdom</title>
<style>
body { margin: 0; overflow: hidden; font-family: sans-serif; color: white; }
#background { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-image: url('https://www.shutterstock.com/blog/wp-content/uploads/sites/5/2021/01/shutterstock_112280795.jpg?w=750'); background-repeat: repeat; background-size: 350px 350px; filter: brightness(50%); }
canvas { display: block; background: transparent; }
#hud { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; font-size: 16px; z-index: 1; }
.ability { margin-bottom: 5px; }
.ready { color: #0f0; }
.cooldown { color: #f00; }
#loadingScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; }
#loadingBarContainer { width: 300px; height: 20px; background: #333; border: 1px solid #666; border-radius: 10px; overflow: hidden; }
#loadingBar { width: 0; height: 100%; background: #0f0; transition: width 0.3s ease; }
#loadingText { color: white; margin-top: 10px; font-size: 18px; }
</style>
</head>
<body>
<div id="loadingScreen">
    <div id="loadingBarContainer"><div id="loadingBar"></div></div>
    <div id="loadingText">Laden... 0%</div>
</div>
<div id="background"></div>
<div id="hud">
    <div class="ability" id="dash">Dash (Shift): Ready</div>
    <div class="ability" id="airhop">Air Hop (Space): Ready</div>
    <div class="ability" id="sword">Sword (C): Ready</div>
</div>
<canvas id="gameCanvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
const CONFIG = {
    gravity: 1.2,
    player: { size:50, speed:5, dashSpeed:15, jumpVelocity:-15, airHopVelocity:-12, dashDuration:100, dashCooldown:2000, hopCooldown:1500, rotationLerp:0.2, collisionFilter:{category:0x0001, mask:0x0002} },
    sword: { height:25, swingDuration:200, swingArc:Math.PI/2, offsetX:35, offsetY:0, collisionFilter:{category:0x0008, mask:0x0002} },
    camera: { smoothFactor:0.2, bgPanSpeed:0.5 },
    sensor: { size:10, offsetY:5, collisionFilter:{category:0x0010, mask:0x0002} }
};
const mapData = { 
    playerStart: {x:200,y:-100,w:50,h:50}, 
    textures:["https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Grey_rough_granite_rock_seamless_stone_surface_texture.jpg/1200px-Grey_rough_granite_rock_seamless_stone_surface_texture.jpg"], 
    platforms:[
        {x:226,y:-39,w:100,h:20,id:"obj1",textureId:0,angle:0},
        {x:224,y:-149,w:100,h:20,id:"obj2",textureId:0,angle:0},
        {x:317,y:-142,w:100,h:20,id:"obj3",textureId:0,angle:10},
        {x:323,y:-31,w:100,h:20,id:"obj4",textureId:0,angle:10},
        {x:469,y:-22,w:200,h:20,id:"obj5",textureId:0,angle:0},
        {x:465,y:-133,w:200,h:20,id:"obj7",textureId:0,angle:0}
    ],
    decor:[
        {x:400,y:-100,w:80,h:80,textureId:0,layer:"behind"},
        {x:600,y:-50,w:100,h:100,textureId:0,layer:"front"}
    ]
};
const swordRightUrl='./images/sword-right.png';
const swordLeftUrl='./images/sword-left.png';
const textureCache=new Map();
const imagesToLoad=[...new Set([...mapData.textures, swordRightUrl, swordLeftUrl])];
let imagesLoaded=0;
const DOM={canvas:document.getElementById("gameCanvas"), background:document.getElementById('background'), loadingBar:document.getElementById('loadingBar'), loadingText:document.getElementById('loadingText'), loadingScreen:document.getElementById('loadingScreen'), hud:{dash:document.getElementById('dash'),airhop:document.getElementById('airhop'),sword:document.getElementById('sword')}};
let canvasWidth=window.innerWidth;
let canvasHeight=window.innerHeight;

function preloadImages(){
    imagesToLoad.forEach(src=>{
        const img=new Image();
        img.src=src;
        img.onload=()=>{textureCache.set(src,{w:img.width,h:img.height}); imagesLoaded++; updateLoading();};
        img.onerror=()=>{imagesLoaded++; updateLoading();};
    });
}

function updateLoading(){
    const progress=(imagesLoaded/imagesToLoad.length)*100;
    DOM.loadingBar.style.width=`${progress}%`;
    DOM.loadingText.textContent=`Laden... ${Math.round(progress)}%`;
    if(imagesLoaded===imagesToLoad.length){setTimeout(()=>{DOM.loadingScreen.style.display='none'; startGame();},500);}
}

let gameStarted=false;

function startGame(){
    if(gameStarted) return;
    gameStarted=true;
    const {Engine, Render, Runner, Bodies, World, Body, Events, Composite, Query}=Matter;
    DOM.canvas.width=canvasWidth;
    DOM.canvas.height=canvasHeight;
    const engine=Engine.create();
    engine.world.gravity.y=CONFIG.gravity;
    const render=Render.create({canvas:DOM.canvas, engine:engine, options:{width:canvasWidth,height:canvasHeight,wireframes:false,background:'transparent'}});
    Render.run(render);
    const runner=Runner.create();
    Runner.run(runner,engine);

    const PLATFORM_FRICTION = 0; 
    let player=Bodies.rectangle(mapData.playerStart.x,mapData.playerStart.y,mapData.playerStart.w,mapData.playerStart.h,{restitution:0,friction:0,frictionAir:0.02,render:{fillStyle:'#f00'},label:'player',inertia:Infinity,collisionFilter:CONFIG.player.collisionFilter});
    player.render.zIndex = 1;
    World.add(engine.world,player);

    let camPos={x:mapData.playerStart.x, y:mapData.playerStart.y};
    let camTarget={x:camPos.x, y:camPos.y};

    mapData.platforms.forEach(p=>{
        const texture=mapData.textures[p.textureId];
        const imgSize=textureCache.get(texture)||{w:p.w,h:p.h};
        const platform=Bodies.rectangle(p.x,p.y,p.w,p.h,{
            isStatic:true,
            restitution:0,
            friction:PLATFORM_FRICTION,
            render:texture?{sprite:{texture,xScale:p.w/imgSize.w,yScale:p.h/imgSize.h}}:{fillStyle:'#654321'},
            label:p.angle!==0?'slope':'static-platform',
            angle:(p.angle||0)*Math.PI/180,
            collisionFilter:{category:0x0002, mask:0x0001},
            zIndex:0
        });
        World.add(engine.world,platform);
        
    });

    mapData.decor?.forEach(d=>{
        const texture = mapData.textures[d.textureId];
        const imgSize = textureCache.get(texture) || {w:d.w,h:d.h};
        const decor=Bodies.rectangle(d.x,d.y,d.w,d.h,{isStatic:true,isSensor:true,render:texture?{sprite:{texture,xScale:d.w/imgSize.w,yScale:d.h/imgSize.h}}:{fillStyle:'#888'},label:'decor',collisionFilter:{mask:0x0000}});
        if(d.layer==='behind') decor.render.zIndex=-1;
        else if(d.layer==='front') decor.render.zIndex=2;
        World.add(engine.world,decor);
    });

    let sword;
    const swordScale = (CONFIG.player.size*0.5)/220;
    sword = Bodies.rectangle(-1000,-1000,540*swordScale,220*swordScale,{isSensor:false,restitution:0,render:{sprite:{texture:swordRightUrl,xScale:swordScale,yScale:swordScale,opacity:1}},label:'sword',collisionFilter:CONFIG.sword.collisionFilter});
    sword.render.zIndex = 1;
    sword.active=false;
    sword.render.visible = false;
    World.add(engine.world,sword);

    const state={keys:{left:false,right:false,up:false,dash:false,hop:false,sword:false},isDashing:false,dashStartTime:0,lastDash:0,lastHop:0,isFrozen:false,activeSword:null,facingDirection:1};
    const keyMap={ArrowLeft:'left',ArrowRight:'right',ArrowUp:'up',ShiftLeft:'dash',ShiftRight:'dash',Space:'hop',KeyC:'sword'};
    document.addEventListener('keydown',e=>{
        if(keyMap[e.code]){
            state.keys[keyMap[e.code]]=true;
            if(e.code==='KeyC') startSwordSwing();
        }
    });
    document.addEventListener('keyup',e=>{if(keyMap[e.code]) state.keys[keyMap[e.code]]=false;});

    let swordInterval = null;
    function startSwordSwing(){
        if(!sword) return;
        if(swordInterval){
            clearInterval(swordInterval);
            sword.active = false;
            sword.render.visible = false;
            sword.isStatic = false;
            Body.setPosition(sword, {x:-1000, y:-1000});
        }
        sword.active = true;
        sword.render.visible = true;
        sword.isStatic = true;
        const dir = state.facingDirection;
        sword.render.sprite.texture = dir === 1 ? swordRightUrl : swordLeftUrl;
        const swingDuration = CONFIG.sword.swingDuration;
        const startAngle = -Math.PI/4;
        const endAngle = Math.PI/4;
        const totalSteps = swingDuration / 16;
        let stepCount = 0;
        swordInterval = setInterval(() => {
            const t = stepCount / totalSteps;
            const angle = startAngle + (endAngle - startAngle) * t;
            const offsetX = CONFIG.sword.offsetX * dir;
            const offsetY = CONFIG.sword.offsetY;
            const x = player.position.x + offsetX * Math.cos(player.angle) - offsetY * Math.sin(player.angle);
            const y = player.position.y + offsetX * Math.sin(player.angle) + offsetY * Math.cos(player.angle);
            Body.setPosition(sword, {x, y});
            Body.setAngle(sword, angle * dir + player.angle);
            stepCount++;
            if(stepCount > totalSteps){
                clearInterval(swordInterval);
                swordInterval = null;
                sword.active = false;
                sword.render.visible = false;
                sword.isStatic = false;
                Body.setPosition(sword, {x:-1000, y:-1000});
            }
        },16);
    }

    function getGroundAngle(){
        const leftSensor = Bodies.rectangle(player.bounds.min.x,player.bounds.max.y+CONFIG.sensor.offsetY,CONFIG.sensor.size,CONFIG.sensor.size,{isSensor:true,isStatic:true});
        const rightSensor = Bodies.rectangle(player.bounds.max.x,player.bounds.max.y+CONFIG.sensor.offsetY,CONFIG.sensor.size,CONFIG.sensor.size,{isSensor:true,isStatic:true});
        const bodies = Composite.allBodies(engine.world);
        const leftColl = Query.collides(leftSensor,bodies);
        const rightColl = Query.collides(rightSensor,bodies);
        World.remove(engine.world,[leftSensor,rightSensor]);
        let leftAngle=null,rightAngle=null;
        leftColl.forEach(c=>{if(['static-platform','slope'].includes(c.bodyA.label)||['static-platform','slope'].includes(c.bodyB.label)) leftAngle=(c.bodyA.label==='player'?c.bodyB.angle:c.bodyA.angle)||0;});
        rightColl.forEach(c=>{if(['static-platform','slope'].includes(c.bodyA.label)||['static-platform','slope'].includes(c.bodyB.label)) rightAngle=(c.bodyA.label==='player'?c.bodyB.angle:c.bodyA.angle)||0;});
        if(leftAngle!==null&&rightAngle!==null) return (leftAngle+rightAngle)/2;
        if(leftAngle!==null) return leftAngle;
        if(rightAngle!==null) return rightAngle;
        return null;
    }

    function isPlayerOnGround(){return getGroundAngle()!==null;}
    function updateHUD(){
        const now=Date.now();
        const dashReady = now-state.lastDash>=CONFIG.player.dashCooldown;
        const hopReady = now-state.lastHop>=CONFIG.player.hopCooldown;
        DOM.hud.dash.className = `ability ${dashReady ? 'ready':'cooldown'}`;
        DOM.hud.dash.textContent = `Dash (Shift): ${dashReady ? 'Ready':Math.ceil((CONFIG.player.dashCooldown-(now-state.lastDash))/1000)+'s'}`;
        DOM.hud.airhop.className = `ability ${hopReady ? 'ready':'cooldown'}`;
        DOM.hud.airhop.textContent = `Air Hop (Space): ${hopReady ? 'Ready':Math.ceil((CONFIG.player.hopCooldown-(now-state.lastHop))/1000)+'s'}`;
        DOM.hud.sword.className='ability ready';
        DOM.hud.sword.textContent='Sword (C): Ready';
    }
    setInterval(updateHUD,100);

    window.addEventListener('resize',()=>{
        canvasWidth=window.innerWidth;
        canvasHeight=window.innerHeight;
        DOM.canvas.width=canvasWidth;
        DOM.canvas.height=canvasHeight;
        render.options.width=canvasWidth;
        render.options.height=canvasHeight;
    });

    Render.lookAt(render,{min:{x:mapData.playerStart.x-canvasWidth/2,y:mapData.playerStart.y-canvasHeight/2},max:{x:mapData.playerStart.x+canvasWidth/2,y:mapData.playerStart.y+canvasHeight/2}});

    Events.on(engine,'beforeUpdate',()=>{
        const now=Date.now();
        if(state.keys.right&&!state.keys.left) state.facingDirection=1;
        else if(state.keys.left&&!state.keys.right) state.facingDirection=-1;
        if(!state.isFrozen){
            if(state.keys.dash && !state.isDashing && now-state.lastDash>=CONFIG.player.dashCooldown){
                let dashDir=0;
                if(state.keys.left) dashDir=-CONFIG.player.dashSpeed;
                if(state.keys.right) dashDir=CONFIG.player.dashSpeed;
                if(dashDir!==0){Body.setVelocity(player,{x:dashDir,y:player.velocity.y}); state.isDashing=true; state.dashStartTime=now; state.lastDash=now;}
            }
            if(state.isDashing && now-state.dashStartTime>=CONFIG.player.dashDuration){state.isDashing=false; Body.setVelocity(player,{x:0,y:player.velocity.y});}
            if(state.keys.hop && !isPlayerOnGround() && now-state.lastHop>=CONFIG.player.hopCooldown){Body.setVelocity(player,{x:player.velocity.x,y:CONFIG.player.airHopVelocity}); state.lastHop=now;}
            if(!state.isDashing){
                const curr=player.velocity.x;
                const target=(state.keys.right?CONFIG.player.speed:0)-(state.keys.left?CONFIG.player.speed:0);
                Body.setVelocity(player,{x:curr+(target-curr)*0.2,y:player.velocity.y});
            }
            if(state.keys.up && isPlayerOnGround()){Body.setVelocity(player,{x:player.velocity.x,y:CONFIG.player.jumpVelocity});}
        }
        const groundAngle=getGroundAngle();
        if(groundAngle!==null){
            const current=player.angle;
            const diff=groundAngle-current;
            let normalized=diff-(2*Math.PI)*Math.round(diff/(2*Math.PI));
            Body.setAngle(player,current+normalized*CONFIG.player.rotationLerp);
        } else {
            const current=player.angle;
            const diff=0-current;
            Body.setAngle(player,current+diff*CONFIG.player.rotationLerp);
        }
        camTarget.x=player.position.x;
        camTarget.y=player.position.y;
        camPos.x+=(camTarget.x-camPos.x)*CONFIG.camera.smoothFactor;
        camPos.y+=(camTarget.y-camPos.y)*CONFIG.camera.smoothFactor;
        const camX=camPos.x-canvasWidth/2;
        const camY=camPos.y-canvasHeight/2;
        render.bounds.min.x=camX; render.bounds.min.y=camY;
        render.bounds.max.x=camX+canvasWidth; render.bounds.max.y=camY+canvasHeight;
        Render.lookAt(render,{min:{x:camX,y:camY}, max:{x:camX+canvasWidth,y:camY+canvasHeight}});
        DOM.background.style.backgroundPosition=`${-camX*CONFIG.camera.bgPanSpeed}px ${-camY*CONFIG.camera.bgPanSpeed}px`;
        const margin=500;
        const cullBounds={min:{x:camX-margin,y:camY-margin},max:{x:camX+canvasWidth+margin,y:camY+canvasHeight+margin}};
        const bodies = Composite.allBodies(engine.world);
        bodies.sort((a,b)=> (a.render.zIndex||0) - (b.render.zIndex||0));
        bodies.forEach(body=>{
            if(body.label==='player' || body.label==='sword'){ body.render.visible=true; return; }
            const b=body.bounds;
            const inView=b.max.x>cullBounds.min.x && b.min.x<cullBounds.max.x && b.max.y>cullBounds.min.y && b.min.y<cullBounds.max.y;
            body.render.visible = inView;
            if(!inView){
                body.collisionFilter.mask = 0x0000;
            } else {
                if(body.label==='slope'||body.label==='static-platform'){
                    body.collisionFilter.mask = 0x0001;
                }
            }
        });
    });
}
preloadImages();
</script>
</body>
</html>
