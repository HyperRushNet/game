<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fallen Kingdom Map Editor</title>
<style>
body { margin:0; display:flex; height:100vh; font-family:'Segoe UI',sans-serif; background:#111; color:#fff; }
#editor { flex:1; position:relative; cursor:crosshair; overflow:hidden; background:linear-gradient(135deg,#1a1a1a,#222); }
canvas { display:block; }
#sidebar { width:320px; background:#0c0c0c; padding:20px; overflow-y:auto; box-shadow:0 0 20px #000; border-left:1px solid #0ff; }
h2 { margin:10px 0; font-size:20px; font-weight:600; color:#0ff; border-bottom:1px solid #0ff; padding-bottom:5px; }
label { display:block; margin-top:12px; font-size:14px; color:#aaa; }
input, select, textarea, button { width:100%; margin-top:6px; background:#111; color:#0ff; border:1px solid #0ff; padding:6px; border-radius:6px; font-family:monospace; font-size:13px; transition:0.2s; }
input:focus, select:focus, textarea:focus { outline:none; border-color:#0f0; box-shadow:0 0 8px #0f0; }
button { cursor:pointer; border:1px solid #0ff; color:#0ff; background:transparent; transition:0.2s; }
button:hover { background:#0ff; color:#000; }
textarea { height:120px; resize:none; }
.layer-controls { display: flex; gap: 10px; margin-top: 10px; }
.layer-btn { flex: 1; padding: 8px; font-size: 12px; }
</style>
</head>
<body>
<div id="editor">
  <canvas id="canvas"></canvas>
</div>
<div id="sidebar">
  <h2>JSON Import / Export</h2>
  <textarea id="jsonIn" placeholder="Paste JSON here"></textarea>
  <button id="loadJsonBtn">Load JSON</button>
  <button id="clearBtn">Clear Map</button>
  <button id="resetBtn">Reset Map</button>

  <h2>Selected Object</h2>
  <label>Type
    <select id="propType"><option value="platform">Platform</option><option value="wall">Wall</option><option value="decor">Decor</option></select>
  </label>
  <label>Z-Index <input type="number" id="propZIndex"></label>
  <div class="layer-controls">
    <button class="layer-btn" id="moveToFront">To Front</button>
    <button class="layer-btn" id="moveToBack">To Back</button>
    <button class="layer-btn" id="moveUp">Up</button>
    <button class="layer-btn" id="moveDown">Down</button>
  </div>
  <label>X <input type="number" id="propX"></label>
  <label>Y <input type="number" id="propY"></label>
  <label>Width <input type="number" id="propW"></label>
  <label>Height <input type="number" id="propH"></label>
  <label>Rotation <input type="number" id="propAngle"></label>
  <label>Texture URL <input type="text" id="propTextureUrl" placeholder="Enter image or video URL"></label>

  <h2>Player</h2>
  <label>Z-Index <input type="number" id="playerZIndex"></label>
  <label>X <input type="number" id="playerX"></label>
  <label>Y <input type="number" id="playerY"></label>
  <label>Width <input type="number" id="playerW"></label>
  <label>Height <input type="number" id="playerH"></label>

  <h2>Live JSON</h2>
  <textarea id="jsonOut" readonly></textarea>
  <div style="margin-top:10px;">
  <button id="toggleHelp" style="width:100%; margin-top:10px;">Show Instructions</button>
  <div id="helpContent" style="display:none; margin-top:10px; font-size:12px; color:#ccc; max-height:200px; overflow-y:auto; background:#111; border:1px solid #0ff; padding:10px; border-radius:6px;">
    <strong>Fallen Kingdom Map Editor Instructions:</strong>
    <p>Welcome to the map editor! Here's how to use it:</p>
    <ul>
      <li><strong>Select or create objects:</strong> Click on an object to select it, or click empty space to create a new platform.</li>
      <li><strong>Move objects:</strong> Drag the selected object, or use arrow keys for fine adjustments. Hold Shift to move faster.</li>
      <li><strong>Resize and rotate:</strong> Use the sidebar inputs for width, height, and rotation.</li>
      <li><strong>Layering:</strong> Adjust Z-index or use "To Front"/"To Back"/"Up"/"Down" buttons to control overlapping.</li>
      <li><strong>Textures:</strong> Enter an image or video URL in the Texture URL field.</li>
      <li><strong>Player:</strong> Adjust the player start position and size in the Player section.</li>
      <li><strong>Zoom & Pan:</strong> Scroll the mouse wheel to zoom. Hold Shift + drag to pan the canvas.</li>
      <li><strong>Clipboard:</strong> Ctrl+C to copy, Ctrl+V to paste objects.</li>
      <li><strong>Delete:</strong> Press Backspace to remove the selected object.</li>
      <li><strong>JSON:</strong> Use the Import/Export section to save or load your map.</li>
      <li><strong>Sidebar:</strong> When the mouse is over the sidebar, canvas interactions are paused.</li>
    </ul>
  </div>
</div>

</div>

<script>
const toggleHelpBtn = document.getElementById("toggleHelp");
const helpContent = document.getElementById("helpContent");

toggleHelpBtn.addEventListener("click", () => {
  if(helpContent.style.display === "none"){
    helpContent.style.display = "block";
    toggleHelpBtn.textContent = "Hide Instructions";
  } else {
    helpContent.style.display = "none";
    toggleHelpBtn.textContent = "Show Instructions";
  }
});

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const sidebar = document.getElementById("sidebar");
const sidebarWidth = 320;

canvas.width = window.innerWidth - sidebarWidth;
canvas.height = window.innerHeight;

let camX = 0, camY = 0, isPanning = false, panStartX = 0, panStartY = 0;
let scale = 1, zoomSpeed = 0.1;
let sidebarActive = false;

// Sidebar hover blocks canvas interactions
sidebar.addEventListener("mouseenter", () => sidebarActive = true);
sidebar.addEventListener("mouseleave", () => sidebarActive = false);

let objects = [], selected = null, dragging = false, dragOffsetX = 0, dragOffsetY = 0;
let player = {x:200, y:200, w:50, h:50, zIndex:1};
let clipboard = null;
const imageCache = new Map();
const videoCache = new Map();

// --- ID generator ---
function generateId() {
  const chars="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let part1="", part2="";
  for(let i=0;i<12;i++) part1+=chars[Math.floor(Math.random()*chars.length)];
  for(let i=0;i<12;i++) part2+=chars[Math.floor(Math.random()*chars.length)];
  return part1+"-"+part2;
}

// --- Sidebar elements ---
const propType=document.getElementById("propType");
const propZIndex=document.getElementById("propZIndex");
const propX=document.getElementById("propX");
const propY=document.getElementById("propY");
const propW=document.getElementById("propW");
const propH=document.getElementById("propH");
const propAngle=document.getElementById("propAngle");
const propTextureUrl=document.getElementById("propTextureUrl");
const playerZIndex=document.getElementById("playerZIndex");
const playerX=document.getElementById("playerX");
const playerY=document.getElementById("playerY");
const playerW=document.getElementById("playerW");
const playerH=document.getElementById("playerH");
const jsonOut=document.getElementById("jsonOut");
const jsonIn=document.getElementById("jsonIn");
const loadJsonBtn=document.getElementById("loadJsonBtn");
const clearBtn=document.getElementById("clearBtn");
const resetBtn=document.getElementById("resetBtn");
const moveToFront=document.getElementById("moveToFront");
const moveToBack=document.getElementById("moveToBack");
const moveUp=document.getElementById("moveUp");
const moveDown=document.getElementById("moveDown");

// --- Layering helpers ---
function getMaxZIndex(){ return objects.length>0?Math.max(...objects.map(o=>o.zIndex||0)):0; }
function getMinZIndex(){ return objects.length>0?Math.min(...objects.map(o=>o.zIndex||0)):0; }

// --- Draw ---
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.scale(scale, scale);
  ctx.translate(-camX,-camY);

  const sortedObjects = objects.slice().sort((a,b)=>(a.zIndex||0)-(b.zIndex||0));
  sortedObjects.forEach(o=>{
    ctx.save();
    ctx.translate(o.x,o.y);
    ctx.rotate((o.angle||0)*Math.PI/180);

    if(o.texture){
      if(o.texture.endsWith('.webm')||o.texture.endsWith('.mp4')){
        if(!videoCache.has(o.texture)){
          const video=document.createElement('video');
          video.src=o.texture; video.crossOrigin="anonymous"; video.muted=true; video.playsInline=true;
          video.preload="auto"; video.loop=true;
          video.addEventListener('loadedmetadata',()=>{ videoCache.set(o.texture,{video,w:video.videoWidth,h:video.videoHeight,loaded:true,isPlaying:false}); video.play().catch(()=>{}); draw(); });
          video.onerror=()=>{ videoCache.set(o.texture,{video:null,w:0,h:0,loaded:true,isPlaying:false}); draw(); };
        }
        const vdata = videoCache.get(o.texture);
        if(vdata && vdata.loaded && vdata.video && vdata.video.readyState>=2){
          const inView = o.x+o.w/2>camX && o.x-o.w/2<camX+canvas.width/scale && o.y+o.h/2>camY && o.y-o.h/2<camY+canvas.height/scale;
          if(inView && !vdata.isPlaying){ vdata.video.play().catch(()=>{}); vdata.isPlaying=true; }
          else if(!inView && vdata.isPlaying){ vdata.video.pause(); vdata.isPlaying=false; }
          ctx.drawImage(vdata.video,-o.w/2,-o.h/2,o.w,o.h);
        } else ctx.fillStyle="#888"; ctx.fillRect(-o.w/2,-o.h/2,o.w,o.h);
      } else {
        if(!imageCache.has(o.texture)){
          const img=new Image();
          img.src=o.texture; img.crossOrigin="anonymous";
          img.onload=()=>draw(); img.onerror=()=>console.warn("Broken image:",o.texture);
          imageCache.set(o.texture,img);
        }
        const img=imageCache.get(o.texture);
        if(img && img.complete && img.naturalWidth>0) ctx.drawImage(img,-o.w/2,-o.h/2,o.w,o.h);
        else{ ctx.fillStyle="#888"; ctx.fillRect(-o.w/2,-o.h/2,o.w,o.h); }
      }
    } else ctx.fillStyle = o.type === "platform"? "#654321": o.type==="wall"? "#444": "#880088", ctx.fillRect(-o.w/2,-o.h/2,o.w,o.h);

    if(o===selected){ ctx.strokeStyle="cyan"; ctx.lineWidth=3; ctx.strokeRect(-o.w/2,-o.h/2,o.w,o.h); }
    ctx.restore();
  });

  // Draw player
  ctx.save();
  ctx.translate(player.x,player.y);
  ctx.fillStyle="lime";
  ctx.fillRect(-player.w/2,-player.h/2,player.w,player.h);
  ctx.strokeStyle="#0ff"; ctx.lineWidth=2;
  ctx.strokeRect(-player.w/2,-player.h/2,player.w,player.h);
  ctx.fillStyle="#fff"; ctx.font="12px monospace"; ctx.fillText("PLAYER",-player.w/2+5,-player.h/2+15);
  ctx.restore();

  ctx.restore();
}

// --- Update props ---
function updateProps(){
  if(selected){
    propType.value=selected.type||"platform";
    propZIndex.value=selected.zIndex||0;
    propX.value=Math.round(selected.x); propY.value=Math.round(selected.y);
    propW.value=Math.round(selected.w); propH.value=Math.round(selected.h);
    propAngle.value=Math.round(selected.angle||0);
    propTextureUrl.value=selected.texture||"";
  } else { propType.value="platform"; propZIndex.value=0; propX.value=""; propY.value=""; propW.value=""; propH.value=""; propAngle.value=0; propTextureUrl.value=""; }
  playerZIndex.value=player.zIndex; playerX.value=player.x; playerY.value=player.y; playerW.value=player.w; playerH.value=player.h;
  updateJSON();
}

function applyProps(){
  if(selected){
    selected.type=propType.value;
    selected.zIndex=parseInt(propZIndex.value)||0;
    selected.x=parseInt(propX.value)||0; selected.y=parseInt(propY.value)||0;
    selected.w=parseInt(propW.value)||10; selected.h=parseInt(propH.value)||10;
    selected.angle=parseFloat(propAngle.value)||0;
    selected.texture=propTextureUrl.value||null;
  }
  player.zIndex=parseInt(playerZIndex.value)||1;
  player.x=parseInt(playerX.value)||0; player.y=parseInt(playerY.value)||0;
  player.w=parseInt(playerW.value)||50; player.h=parseInt(playerH.value)||50;
  draw(); updateJSON();
}

[propType,propZIndex,propX,propY,propW,propH,propAngle,playerZIndex,playerX,playerY,playerW,playerH].forEach(i=>i.addEventListener("input",applyProps));
propTextureUrl.addEventListener("input",(e)=>{ if(selected){ selected.texture=e.target.value||null; draw(); updateJSON(); }});

// --- JSON ---
function updateJSON(){
  const textures=[];
  objects.forEach(o=>{ if(o.texture && !textures.includes(o.texture)) textures.push(o.texture); });
  const platforms = objects.filter(o=>o.type==="platform"||o.type==="wall").map(o=>({
    id:o.id||generateId(), type:o.type, x:o.x, y:o.y, w:o.w, h:o.h, angle:o.angle||0,
    textureId:o.texture?textures.indexOf(o.texture):null, zIndex:o.zIndex||0
  }));
  const decor = objects.filter(o=>o.type==="decor").map(o=>({
    id:o.id||generateId(), type:"decor", x:o.x, y:o.y, w:o.w, h:o.h, angle:o.angle||0,
    textureId:o.texture?textures.indexOf(o.texture):null, zIndex:o.zIndex||0
  }));
  const json={playerStart:{...player}, textures, platforms, decor};
  jsonOut.value=JSON.stringify(json,null,2);
  localStorage.setItem("fkmapeditor",JSON.stringify(json));
}

// --- Point in rect ---
function pointInRotatedRect(px,py,o){
  const rad=-(o.angle||0)*Math.PI/180;
  const dx=px-o.x, dy=py-o.y;
  const localX=dx*Math.cos(rad)-dy*Math.sin(rad);
  const localY=dx*Math.sin(rad)+dy*Math.cos(rad);
  return localX>=-o.w/2 && localX<=o.w/2 && localY>=-o.h/2 && localY<=o.h/2;
}

// --- Mouse ---
canvas.addEventListener("mousedown",e=>{
  if(sidebarActive) return;
  const x=e.offsetX/scale+camX, y=e.offsetY/scale+camY;
  if(e.shiftKey){ isPanning=true; panStartX=e.clientX; panStartY=e.clientY; return; }
  let clicked=null;
  const sorted=objects.slice().sort((a,b)=>(b.zIndex||0)-(a.zIndex||0));
  for(let o of sorted){ if(pointInRotatedRect(x,y,o)){ clicked=o; break; } }
  if(clicked){ selected=clicked; dragging=true; dragOffsetX=x-selected.x; dragOffsetY=y-selected.y; }
  else{ selected={x,y,w:100,h:20,angle:0,texture:null,type:"platform",zIndex:getMaxZIndex()+1,id:generateId()}; objects.push(selected); dragging=true; dragOffsetX=0; dragOffsetY=0; }
  updateProps(); draw();
});

canvas.addEventListener("mousemove",e=>{
  if(sidebarActive) return;
  const x=e.offsetX/scale+camX, y=e.offsetY/scale+camY;
  if(isPanning){ camX-=(e.clientX-panStartX)/scale; camY-=(e.clientY-panStartY)/scale; panStartX=e.clientX; panStartY=e.clientY; draw(); }
  else if(dragging && selected){ selected.x=x-dragOffsetX; selected.y=y-dragOffsetY; updateProps(); draw(); }
});

canvas.addEventListener("mouseup",()=>{ dragging=false; isPanning=false; });

// --- DISABLE right-click delete ---
canvas.addEventListener("contextmenu", e=>{ e.preventDefault(); });

// --- Zoom ---
canvas.addEventListener("wheel",e=>{
  if(sidebarActive){ e.preventDefault(); return; }
  e.preventDefault();
  const zoom=e.deltaY<0?1+zoomSpeed:1-zoomSpeed;
  const mx=(e.offsetX/scale+camX); const my=(e.offsetY/scale+camY);
  scale*=zoom; scale=Math.min(Math.max(scale,0.2),5);
  camX=mx-(e.offsetX/scale); camY=my-(e.offsetY/scale);
  draw();
});

// --- Keyboard ---
window.addEventListener("keydown", e => {
  if(sidebarActive) return;
  if(!selected) return;

  if(e.ctrlKey && e.key==="c"){ clipboard={...selected}; return; }
  if(e.ctrlKey && e.key==="v" && clipboard){ const newObj={...clipboard,id:generateId(),x:clipboard.x+20,y:clipboard.y+20,zIndex:getMaxZIndex()+1}; objects.push(newObj); selected=newObj; updateProps(); draw(); return; }

  // DELETE with Backspace
  if(e.key === "Backspace"){ e.preventDefault(); objects = objects.filter(o=>o!==selected); selected=null; updateProps(); draw(); return; }

  // Arrow movement
  switch(e.key){
    case "ArrowLeft": selected.x-=(e.shiftKey?20:5)/scale; break;
    case "ArrowRight": selected.x+=(e.shiftKey?20:5)/scale; break;
    case "ArrowUp": selected.y-=(e.shiftKey?20:5)/scale; break;
    case "ArrowDown": selected.y+=(e.shiftKey?20:5)/scale; break;
    default: return;
  }
  updateProps(); draw();
});

// --- Layer buttons ---
moveToFront.addEventListener("click",()=>{ if(selected){ selected.zIndex=getMaxZIndex()+1; updateProps(); draw(); } });
moveToBack.addEventListener("click",()=>{ if(selected){ selected.zIndex=getMinZIndex()-1; updateProps(); draw(); } });
moveUp.addEventListener("click",()=>{ if(selected){ selected.zIndex=(selected.zIndex||0)+1; updateProps(); draw(); } });
moveDown.addEventListener("click",()=>{ if(selected){ selected.zIndex=(selected.zIndex||0)-1; updateProps(); draw(); } });

// --- JSON buttons ---
loadJsonBtn.addEventListener("click", ()=>{
  try{
    const data=JSON.parse(jsonIn.value);
    player={...data.playerStart,zIndex:data.playerStart.zIndex||1};
    objects=[];
    (data.platforms||[]).forEach(p=>objects.push({...p,type:p.type,zIndex:p.zIndex||0,texture:data.textures?.[p.textureId]||null,id:p.id||generateId()}));
    (data.decor||[]).forEach(d=>objects.push({...d,type:"decor",zIndex:d.zIndex||0,texture:data.textures?.[d.textureId]||null,id:d.id||generateId()}));
    selected=null; draw(); updateProps();
  }catch(err){ alert("Invalid JSON: "+err); }
});

clearBtn.addEventListener("click", ()=>{ objects=[]; selected=null; draw(); updateJSON(); });
resetBtn.addEventListener("click", ()=>{ objects=[]; selected=null; player={x:200,y:200,w:50,h:50,zIndex:1}; draw(); updateJSON(); });

// --- Load localStorage ---
const saved = localStorage.getItem("fkmapeditor");
if(saved){ try{ const data=JSON.parse(saved); player={...data.playerStart,zIndex:data.playerStart.zIndex||1}; objects=[]; (data.platforms||[]).forEach(p=>objects.push({...p,type:p.type,zIndex:p.zIndex||0,texture:data.textures?.[p.textureId]||null,id:p.id||generateId()})); (data.decor||[]).forEach(d=>objects.push({...d,type:"decor",zIndex:d.zIndex||0,texture:data.textures?.[d.textureId]||null,id:p.id||generateId()})); draw(); updateProps(); }catch{} }

// --- Animate ---
function animate(){ draw(); requestAnimationFrame(animate); }
animate();

window.addEventListener("resize",()=>{ canvas.width=window.innerWidth-sidebarWidth; canvas.height=window.innerHeight; draw(); });
</script>
</body>
</html>
