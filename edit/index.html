<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fallen Kingdom Map Editor</title>
<style>
body { margin:0; display:flex; height:100vh; font-family:'Segoe UI',sans-serif; background:#111; color:#fff; }
#editor { flex:1; position:relative; cursor:crosshair; overflow:hidden; background:linear-gradient(135deg,#1a1a1a,#222); }
canvas { display:block; }
#sidebar { width:320px; background:#0c0c0c; padding:20px; overflow-y:auto; box-shadow:0 0 20px #000; border-left:1px solid #0ff; }
h2 { margin:10px 0; font-size:20px; font-weight:600; color:#0ff; border-bottom:1px solid #0ff; padding-bottom:5px; }
label { display:block; margin-top:12px; font-size:14px; color:#aaa; }
input, select, textarea, button { width:100%; margin-top:6px; background:#111; color:#0ff; border:1px solid #0ff; padding:6px; border-radius:6px; font-family:monospace; font-size:13px; transition:0.2s; }
input:focus, select:focus, textarea:focus { outline:none; border-color:#0f0; box-shadow:0 0 8px #0f0; }
button { cursor:pointer; border:1px solid #0ff; color:#0ff; background:transparent; transition:0.2s; }
button:hover { background:#0ff; color:#000; }
textarea { height:120px; resize:none; }
.layer-controls { display: flex; gap: 10px; margin-top: 10px; }
.layer-btn { flex: 1; padding: 8px; font-size: 12px; }
</style>
</head>
<body>
<div id="editor">
  <canvas id="canvas"></canvas>
</div>
<div id="sidebar">
  <h2>JSON Import / Export</h2>
  <textarea id="jsonIn" placeholder="Paste JSON here"></textarea>
  <button id="loadJsonBtn">Load JSON</button>
  <button id="clearBtn">Clear Map</button>
  <button id="resetBtn">Reset Map</button>
  <h2>Selected Object</h2>
  <label>Type
    <select id="propType"><option value="platform">Platform</option><option value="wall">Wall</option><option value="decor">Decor</option></select>
  </label>
  <label>Z-Index <input type="number" id="propZIndex"></label>
  <div class="layer-controls">
    <button class="layer-btn" id="moveToFront">To Front</button>
    <button class="layer-btn" id="moveToBack">To Back</button>
    <button class="layer-btn" id="moveUp">Up</button>
    <button class="layer-btn" id="moveDown">Down</button>
  </div>
  <label>X <input type="number" id="propX"></label>
  <label>Y <input type="number" id="propY"></label>
  <label>Width <input type="number" id="propW"></label>
  <label>Height <input type="number" id="propH"></label>
  <label>Rotation <input type="number" id="propAngle"></label>
  <label>Texture URL <input type="text" id="propTextureUrl" placeholder="Enter image or video URL"></label>
  <h2>Player</h2>
  <label>Z-Index <input type="number" id="playerZIndex"></label>
  <label>X <input type="number" id="playerX"></label>
  <label>Y <input type="number" id="playerY"></label>
  <label>Width <input type="number" id="playerW"></label>
  <label>Height <input type="number" id="playerH"></label>
  <h2>Live JSON</h2>
  <textarea id="jsonOut" readonly></textarea>
  <div style="margin-top:10px;">
    <button id="toggleHelp" style="width:100%; margin-top:10px;">Show Instructions</button>
    <div id="helpContent" style="display:none; margin-top:10px; font-size:12px; color:#ccc; max-height:200px; overflow-y:auto; background:#111; border:1px solid #0ff; padding:10px; border-radius:6px;">
      <strong>Fallen Kingdom Map Editor Instructions:</strong>
      <p>Welcome to the map editor! Here's how to use it:</p>
      <ul>
        <li><strong>Select or create objects:</strong> Click on an object to select it, or click empty space to create a new platform.</li>
        <li><strong>Move objects:</strong> Drag the selected object, or use arrow keys for fine adjustments (1px, or 10px with Shift).</li>
        <li><strong>Resize and rotate:</strong> Use the sidebar inputs for width, height, and rotation.</li>
        <li><strong>Layering:</strong> Adjust Z-index or use "To Front"/"To Back"/"Up"/"Down" buttons to control overlapping.</li>
        <li><strong>Textures:</strong> Enter an image or video URL in the Texture URL field.</li>
        <li><strong>Player:</strong> Adjust the player start position and size in the Player section.</li>
        <li><strong>Zoom & Pan:</strong> Scroll the mouse wheel to zoom. Hold Shift + drag to pan the canvas.</li>
        <li><strong>Clipboard:</strong> Ctrl+C to copy, Ctrl+V to paste objects.</li>
        <li><strong>Delete:</strong> Press Backspace to remove the selected object.</li>
        <li><strong>JSON:</strong> Use the Import/Export section to save or load your map.</li>
        <li><strong>Sidebar:</strong> When the mouse is over the sidebar, canvas interactions are paused.</li>
      </ul>
    </div>
  </div>
</div>
<script>
// UI Elements
const toggleHelpBtn = document.getElementById("toggleHelp");
const helpContent = document.getElementById("helpContent");
toggleHelpBtn.addEventListener("click", () => {
  helpContent.style.display = helpContent.style.display === "none" ? "block" : "none";
  toggleHelpBtn.textContent = helpContent.style.display === "none" ? "Show Instructions" : "Hide Instructions";
});

// Canvas setup
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const sidebar = document.getElementById("sidebar");
const sidebarWidth = 320;
canvas.width = window.innerWidth - sidebarWidth;
canvas.height = window.innerHeight;

// Camera and view state
let camX = 0, camY = 0, isPanning = false, panStartX = 0, panStartY = 0;
let scale = 1, zoomSpeed = 0.1;
let sidebarActive = false;

// Sidebar hover blocks canvas interactions
sidebar.addEventListener("mouseenter", () => sidebarActive = true);
sidebar.addEventListener("mouseleave", () => sidebarActive = false);

// Game state
let objects = [], selected = null, dragging = false, dragOffsetX = 0, dragOffsetY = 0;
let player = {x: 200, y: 200, w: 50, h: 50, zIndex: 1};
let clipboard = null;

// Media caches with proper video handling
const imageCache = new Map();
const videoCache = new Map();

// Video management system
class VideoManager {
  constructor() {
    this.activeVideos = new Set();
    this.maxActiveVideos = 4; // Limit simultaneous videos for performance
  }
  getVideo(src) {
    if (!videoCache.has(src)) {
      const video = document.createElement('video');
      video.src = src;
      video.crossOrigin = "anonymous";
      video.muted = true;
      video.playsInline = true;
      video.preload = "auto";
      video.loop = true;
      videoCache.set(src, {
        video,
        w: 1, h: 1,
        loaded: false,
        isPlaying: false,
        ready: false
      });
      video.addEventListener('loadedmetadata', () => {
        const cache = videoCache.get(src);
        if (cache) {
          cache.w = video.videoWidth;
          cache.h = video.videoHeight;
          cache.loaded = true;
          cache.ready = video.readyState >= 2;
        }
      });
      video.addEventListener('canplay', () => {
        const cache = videoCache.get(src);
        if (cache) cache.ready = true;
      });
      video.addEventListener('error', () => {
        const cache = videoCache.get(src);
        if (cache) cache.ready = false;
        console.warn('Video load error:', src);
      });
    }
    return videoCache.get(src);
  }
  playVideo(src) {
    const cache = videoCache.get(src);
    if (!cache || !cache.loaded || !cache.ready) return false;
    if (this.activeVideos.size >= this.maxActiveVideos) {
      const first = this.activeVideos.values().next().value;
      if (first) {
        first.video.pause();
        first.isPlaying = false;
        this.activeVideos.delete(first);
      }
    }
    cache.video.play().catch(e => {
      console.warn('Video playback failed:', e);
      cache.isPlaying = false;
      return false;
    });
    cache.isPlaying = true;
    this.activeVideos.add(cache);
    return true;
  }
  pauseVideo(src) {
    const cache = videoCache.get(src);
    if (cache && cache.isPlaying) {
      cache.video.pause();
      cache.isPlaying = false;
      this.activeVideos.delete(cache);
    }
  }
  isVideoPlaying(src) {
    const cache = videoCache.get(src);
    return cache && cache.isPlaying;
  }
}
const videoManager = new VideoManager();

// ID generator
function generateId() {
  const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let part1 = "", part2 = "";
  for (let i = 0; i < 12; i++) part1 += chars[Math.floor(Math.random() * chars.length)];
  for (let i = 0; i < 12; i++) part2 += chars[Math.floor(Math.random() * chars.length)];
  return part1 + "-" + part2;
}

// Sidebar elements
const propType = document.getElementById("propType");
const propZIndex = document.getElementById("propZIndex");
const propX = document.getElementById("propX");
const propY = document.getElementById("propY");
const propW = document.getElementById("propW");
const propH = document.getElementById("propH");
const propAngle = document.getElementById("propAngle");
const propTextureUrl = document.getElementById("propTextureUrl");
const playerZIndex = document.getElementById("playerZIndex");
const playerX = document.getElementById("playerX");
const playerY = document.getElementById("playerY");
const playerW = document.getElementById("playerW");
const playerH = document.getElementById("playerH");
const jsonOut = document.getElementById("jsonOut");
const jsonIn = document.getElementById("jsonIn");
const loadJsonBtn = document.getElementById("loadJsonBtn");
const clearBtn = document.getElementById("clearBtn");
const resetBtn = document.getElementById("resetBtn");
const moveToFront = document.getElementById("moveToFront");
const moveToBack = document.getElementById("moveToBack");
const moveUp = document.getElementById("moveUp");
const moveDown = document.getElementById("moveDown");

// Layering helpers
function getMaxZIndex() {
  return objects.length > 0 ? Math.max(...objects.map(o => o.zIndex || 0)) : 0;
}
function getMinZIndex() {
  return objects.length > 0 ? Math.min(...objects.map(o => o.zIndex || 0)) : 0;
}

// Draw function with proper z-index handling
function draw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(scale, scale);
  ctx.translate(-camX, -camY);
  const sortedObjects = objects.slice().sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
  const viewBounds = {
    left: camX,
    right: camX + canvas.width / scale,
    top: camY,
    bottom: camY + canvas.height / scale
  };
  sortedObjects.forEach(o => {
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.rotate((o.angle || 0) * Math.PI / 180);
    const objBounds = {
      left: o.x - o.w / 2,
      right: o.x + o.w / 2,
      top: o.y - o.h / 2,
      bottom: o.y + o.h / 2
    };
    const isInView = !(objBounds.right < viewBounds.left ||
                      objBounds.left > viewBounds.right ||
                      objBounds.bottom < viewBounds.top ||
                      objBounds.top > viewBounds.bottom);
    if (o.texture) {
      if (o.texture.match(/\.(webm|mp4)$/i)) {
        const videoData = videoManager.getVideo(o.texture);
        if (videoData && videoData.ready) {
          if (isInView && !videoManager.isVideoPlaying(o.texture)) {
            videoManager.playVideo(o.texture);
          } else if (!isInView && videoManager.isVideoPlaying(o.texture)) {
            videoManager.pauseVideo(o.texture);
          }
          if (videoManager.isVideoPlaying(o.texture) && videoData.ready) {
            ctx.drawImage(videoData.video, -o.w / 2, -o.h / 2, o.w, o.h);
          } else {
            ctx.fillStyle = o.type === "platform" ? "#654321" :
                           o.type === "wall" ? "#444" : "#880088";
            ctx.fillRect(-o.w / 2, -o.h / 2, o.w, o.h);
          }
        } else {
          ctx.fillStyle = "#888";
          ctx.fillRect(-o.w / 2, -o.h / 2, o.w, o.h);
        }
      } else {
        if (!imageCache.has(o.texture)) {
          const img = new Image();
          img.src = o.texture;
          img.crossOrigin = "anonymous";
          img.onload = () => draw();
          img.onerror = () => console.warn("Broken image:", o.texture);
          imageCache.set(o.texture, img);
        }
        const img = imageCache.get(o.texture);
        if (img && img.complete && img.naturalWidth > 0) {
          ctx.drawImage(img, -o.w / 2, -o.h / 2, o.w, o.h);
        } else {
          ctx.fillStyle = "#888";
          ctx.fillRect(-o.w / 2, -o.h / 2, o.w, o.h);
        }
      }
    } else {
      ctx.fillStyle = o.type === "platform" ? "#654321" :
                     o.type === "wall" ? "#444" : "#880088";
      ctx.fillRect(-o.w / 2, -o.h / 2, o.w, o.h);
    }
    if (o === selected) {
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 3 / scale;
      ctx.strokeRect(-o.w / 2, -o.h / 2, o.w, o.h);
    }
    ctx.restore();
  });
  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.fillStyle = "lime";
  ctx.fillRect(-player.w / 2, -player.h / 2, player.w, player.h);
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 2 / scale;
  ctx.strokeRect(-player.w / 2, -player.h / 2, player.w, player.h);
  ctx.fillStyle = "#fff";
  ctx.font = `${12 / scale}px monospace`;
  ctx.textAlign = "center";
  ctx.fillText("PLAYER", 0, -player.h / 2 + 15 / scale);
  ctx.restore();
  ctx.restore();
}

// Update properties from UI
function updateProps() {
  if (selected) {
    propType.value = selected.type || "platform";
    propZIndex.value = selected.zIndex || 0;
    propX.value = Math.round(selected.x);
    propY.value = Math.round(selected.y);
    propW.value = Math.round(selected.w);
    propH.value = Math.round(selected.h);
    propAngle.value = Math.round(selected.angle || 0);
    propTextureUrl.value = selected.texture || "";
  } else {
    propType.value = "platform";
    propZIndex.value = 0;
    propX.value = "";
    propY.value = "";
    propW.value = "";
    propH.value = "";
    propAngle.value = 0;
    propTextureUrl.value = "";
  }
  playerZIndex.value = player.zIndex;
  playerX.value = Math.round(player.x);
  playerY.value = Math.round(player.y);
  playerW.value = Math.round(player.w);
  playerH.value = Math.round(player.h);
  updateJSON();
}

// Apply properties to selected object
function applyProps() {
  if (selected) {
    selected.type = propType.value;
    selected.zIndex = parseInt(propZIndex.value) || 0;
    selected.x = Math.round(parseInt(propX.value) || 0);
    selected.y = Math.round(parseInt(propY.value) || 0);
    selected.w = Math.round(parseInt(propW.value) || 10);
    selected.h = Math.round(parseInt(propH.value) || 10);
    selected.angle = Math.round(parseFloat(propAngle.value) || 0);
    selected.texture = propTextureUrl.value || null;
  }
  player.zIndex = parseInt(playerZIndex.value) || 1;
  player.x = Math.round(parseInt(playerX.value) || 0);
  player.y = Math.round(parseInt(playerY.value) || 0);
  player.w = Math.round(parseInt(playerW.value) || 50);
  player.h = Math.round(parseInt(playerH.value) || 50);
  draw();
  updateJSON();
}

// Set up event listeners for property inputs
[propType, propZIndex, propX, propY, propW, propH, propAngle,
 playerZIndex, playerX, playerY, playerW, playerH].forEach(i => {
  i.addEventListener("input", applyProps);
});

// Special handling for texture URL
propTextureUrl.addEventListener("input", (e) => {
  if (selected) {
    selected.texture = e.target.value || null;
    draw();
    updateJSON();
  }
});

// Update JSON output
function updateJSON() {
  const textures = [];
  objects.forEach(o => {
    if (o.texture && !textures.includes(o.texture)) textures.push(o.texture);
  });
  const platforms = objects.filter(o => o.type === "platform" || o.type === "wall").map(o => ({
    id: o.id || generateId(),
    type: o.type,
    x: Math.round(o.x),
    y: Math.round(o.y),
    w: Math.round(o.w),
    h: Math.round(o.h),
    angle: Math.round(o.angle || 0),
    textureId: o.texture ? textures.indexOf(o.texture) : null,
    zIndex: o.zIndex || 0
  }));
  const decor = objects.filter(o => o.type === "decor").map(o => ({
    id: o.id || generateId(),
    type: "decor",
    x: Math.round(o.x),
    y: Math.round(o.y),
    w: Math.round(o.w),
    h: Math.round(o.h),
    angle: Math.round(o.angle || 0),
    textureId: o.texture ? textures.indexOf(o.texture) : null,
    zIndex: o.zIndex || 0
  }));
  const json = {
    playerStart: {
      x: Math.round(player.x),
      y: Math.round(player.y),
      w: Math.round(player.w),
      h: Math.round(player.h),
      zIndex: player.zIndex
    },
    textures,
    platforms,
    decor
  };
  jsonOut.value = JSON.stringify(json, null, 2);
  localStorage.setItem("fkmapeditor", JSON.stringify(json));
}

// Check if point is in rotated rectangle
function pointInRotatedRect(px, py, o) {
  const rad = -(o.angle || 0) * Math.PI / 180;
  const dx = px - o.x;
  const dy = py - o.y;
  const localX = dx * Math.cos(rad) - dy * Math.sin(rad);
  const localY = dx * Math.sin(rad) + dy * Math.cos(rad);
  return localX >= -o.w / 2 && localX <= o.w / 2 && localY >= -o.h / 2 && localY <= o.h / 2;
}

// Mouse event handlers
canvas.addEventListener("mousedown", e => {
  if (sidebarActive) return;
  const x = Math.round(e.offsetX / scale + camX);
  const y = Math.round(e.offsetY / scale + camY);
  if (e.shiftKey) {
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    return;
  }
  let clicked = null;
  const sorted = objects.slice().sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
  for (let o of sorted) {
    if (pointInRotatedRect(x, y, o)) {
      clicked = o;
      break;
    }
  }
  if (clicked) {
    selected = clicked;
    dragging = true;
    dragOffsetX = x - selected.x;
    dragOffsetY = y - selected.y;
  } else {
    selected = {
      x, y,
      w: 100, h: 20,
      angle: 0,
      texture: null,
      type: "platform",
      zIndex: getMaxZIndex() + 1,
      id: generateId()
    };
    objects.push(selected);
    dragging = true;
    dragOffsetX = 0;
    dragOffsetY = 0;
  }
  updateProps();
  draw();
});

canvas.addEventListener("mousemove", e => {
  if (sidebarActive) return;
  const x = Math.round(e.offsetX / scale + camX);
  const y = Math.round(e.offsetY / scale + camY);
  if (isPanning) {
    camX -= (e.clientX - panStartX) / scale;
    camY -= (e.clientY - panStartY) / scale;
    panStartX = e.clientX;
    panStartY = e.clientY;
    draw();
  } else if (dragging && selected) {
    selected.x = Math.round(x - dragOffsetX);
    selected.y = Math.round(y - dragOffsetY);
    updateProps();
    draw();
  }
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
  isPanning = false;
});

canvas.addEventListener("contextmenu", e => {
  e.preventDefault();
});

canvas.addEventListener("wheel", e => {
  if (sidebarActive) {
    e.preventDefault();
    return;
  }
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
  const mx = (e.offsetX / scale + camX);
  const my = (e.offsetY / scale + camY);
  scale *= zoom;
  scale = Math.min(Math.max(scale, 0.2), 5);
  camX = mx - (e.offsetX / scale);
  camY = my - (e.offsetY / scale);
  draw();
});

// Keyboard shortcuts
window.addEventListener("keydown", e => {
  if (sidebarActive) return;
  if (!selected) return;
  if (e.ctrlKey && e.key === "c") {
    clipboard = {...selected};
    return;
  }
  if (e.ctrlKey && e.key === "v" && clipboard) {
    const newObj = {
      ...clipboard,
      id: generateId(),
      x: Math.round(clipboard.x + 20),
      y: Math.round(clipboard.y + 20),
      zIndex: getMaxZIndex() + 1
    };
    objects.push(newObj);
    selected = newObj;
    updateProps();
    draw();
    return;
  }
  if (e.key === "Backspace") {
    e.preventDefault();
    objects = objects.filter(o => o !== selected);
    selected = null;
    updateProps();
    draw();
    return;
  }
  const moveAmount = e.shiftKey ? 10 : 1;
  switch (e.key) {
    case "ArrowLeft": selected.x = Math.round(selected.x - moveAmount); break;
    case "ArrowRight": selected.x = Math.round(selected.x + moveAmount); break;
    case "ArrowUp": selected.y = Math.round(selected.y - moveAmount); break;
    case "ArrowDown": selected.y = Math.round(selected.y + moveAmount); break;
    default: return;
  }
  updateProps();
  draw();
});

// Layer control buttons
moveToFront.addEventListener("click", () => {
  if (selected) {
    selected.zIndex = getMaxZIndex() + 1;
    updateProps();
    draw();
  }
});
moveToBack.addEventListener("click", () => {
  if (selected) {
    selected.zIndex = getMinZIndex() - 1;
    updateProps();
    draw();
  }
});
moveUp.addEventListener("click", () => {
  if (selected) {
    selected.zIndex = (selected.zIndex || 0) + 1;
    updateProps();
    draw();
  }
});
moveDown.addEventListener("click", () => {
  if (selected) {
    selected.zIndex = (selected.zIndex || 0) - 1;
    updateProps();
    draw();
  }
});

// JSON buttons
loadJsonBtn.addEventListener("click", () => {
  try {
    const data = JSON.parse(jsonIn.value);
    player = {
      x: Math.round(data.playerStart.x),
      y: Math.round(data.playerStart.y),
      w: Math.round(data.playerStart.w),
      h: Math.round(data.playerStart.h),
      zIndex: data.playerStart.zIndex || 1
    };
    objects = [];
    (data.platforms || []).forEach(p => {
      objects.push({
        ...p,
        type: p.type,
        zIndex: p.zIndex || 0,
        texture: data.textures?.[p.textureId] || null,
        id: p.id || generateId(),
        x: Math.round(p.x),
        y: Math.round(p.y),
        w: Math.round(p.w),
        h: Math.round(p.h),
        angle: Math.round(p.angle || 0)
      });
    });
    (data.decor || []).forEach(d => {
      objects.push({
        ...d,
        type: "decor",
        zIndex: d.zIndex || 0,
        texture: data.textures?.[d.textureId] || null,
        id: d.id || generateId(),
        x: Math.round(d.x),
        y: Math.round(d.y),
        w: Math.round(d.w),
        h: Math.round(d.h),
        angle: Math.round(d.angle || 0)
      });
    });
    selected = null;
    draw();
    updateProps();
  } catch (err) {
    alert("Invalid JSON: " + err);
  }
});

clearBtn.addEventListener("click", () => {
  objects = [];
  selected = null;
  draw();
  updateJSON();
});

resetBtn.addEventListener("click", () => {
  objects = [];
  selected = null;
  player = {x: 200, y: 200, w: 50, h: 50, zIndex: 1};
  draw();
  updateJSON();
});

// Load from localStorage if available
const saved = localStorage.getItem("fkmapeditor");
if (saved) {
  try {
    const data = JSON.parse(saved);
    player = {
      x: Math.round(data.playerStart.x),
      y: Math.round(data.playerStart.y),
      w: Math.round(data.playerStart.w),
      h: Math.round(data.playerStart.h),
      zIndex: data.playerStart.zIndex || 1
    };
    objects = [];
    (data.platforms || []).forEach(p => {
      objects.push({
        ...p,
        type: p.type,
        zIndex: p.zIndex || 0,
        texture: data.textures?.[p.textureId] || null,
        id: p.id || generateId(),
        x: Math.round(p.x),
        y: Math.round(p.y),
        w: Math.round(p.w),
        h: Math.round(p.h),
        angle: Math.round(p.angle || 0)
      });
    });
    (data.decor || []).forEach(d => {
      objects.push({
        ...d,
        type: "decor",
        zIndex: d.zIndex || 0,
        texture: data.textures?.[d.textureId] || null,
        id: d.id || generateId(),
        x: Math.round(d.x),
        y: Math.round(d.y),
        w: Math.round(d.w),
        h: Math.round(d.h),
        angle: Math.round(d.angle || 0)
      });
    });
    draw();
    updateProps();
  } catch (e) {
    console.error("Error loading saved data:", e);
  }
}

// Animation loop
function animate() {
  draw();
  requestAnimationFrame(animate);
}
animate();

// Handle window resize
window.addEventListener("resize", () => {
  canvas.width = window.innerWidth - sidebarWidth;
  canvas.height = window.innerHeight;
  draw();
});
</script>
</body>
</html>
